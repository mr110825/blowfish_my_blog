
[{"content":"","date":"2025年 8月 7日","externalUrl":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":" git worktree ハンズオン # 1. はじめに # git worktree とは？ # git worktree は、1つのGitリポジトリに対して、複数のワーキングツリー（作業ディレクトリ）を同時に作成し、管理するためのGitコマンドです。\n通常、git checkout を使ってブランチを切り替えると、現在のワーキングツリーの内容が対象ブランチのものに完全に置き換わります。しかし、git worktree を利用すると、異なるブランチをそれぞれ別のディレクトリにチェックアウトした状態に保つことができます。\ngit worktree はどのような時に便利か？ # この機能は、以下のような状況で非常に役立ちます。\n機能開発とバグ修正の並行作業: 大規模な新機能（例: feature-A）の開発中に、本番環境で発生した緊急のバグ（例: hotfix）にすぐ対応する必要がある場合。feature-Aの作業をgit stashなどで退避させることなく、別のディレクトリでhotfixブランチの作業をすぐに始められます。 複数の機能の同時開発: 複数のフィーチャーブランチを並行して開発し、それぞれの動作確認を簡単に行いたい場合。ブランチごとにディレクトリが分かれているため、ビルド成果物などが混ざり合うこともありません。 2. ハンズオン # Step 0: 準備 # まず、ハンズオン用のリポジトリを準備します。\n# 1. 作業用のディレクトリを作成し、移動します mkdir git-worktree-handson-tutorial cd git-worktree-handson-tutorial # 2. Gitリポジトリを初期化します git init # 3. 最初のファイルを作成してコミットします echo \u0026#34;Hello World\u0026#34; \u0026gt; main.txt git add main.txt git commit -m \u0026#34;first commit\u0026#34; Step 1: feature-A のためのワークツリー作成 # mainブランチとは別の場所で、新しい機能 feature-A の開発に着手します。そのために、専用のワークツリーを作成しましょう。\n# \u0026#39;feature-A\u0026#39; という名前の新しいブランチを、\u0026#39;feature-a-worktree\u0026#39; というディレクトリに作成します git worktree add ./feature-a-worktree -b feature-A ./feature-a-worktree: 新しく作成されるディレクトリのパスです。 -b feature-A: 新しく作成するブランチの名前です。このブランチが feature-a-worktree ディレクトリにチェックアウトされます。 git worktree list コマンドで、現在のワークツリーの状態を確認してみましょう。\ngit worktree list 以下のような出力が表示され、2つのワークツリーが存在することがわかります。\n/path/to/git-worktree-handson-tutorial (bare) /path/to/git-worktree-handson-tutorial/feature-a-worktree [feature-A] Step 2: feature-A ワークツリーでの作業 # feature-A の開発作業を進めます。\n# 1. feature-A のワークツリーに移動します cd feature-a-worktree # 2. 現在のブランチを確認します git branch # =\u0026gt; * feature-A # 3. feature-A のための新しいファイルを作成し、コミットします echo \u0026#34;Goodby World\u0026#34; \u0026gt; feature-A.txt git add feature-A.txt git commit -m \u0026#34;feat: Add feature-A file\u0026#34; これで、feature-Aブランチに新しいコミットが追加されました。\nStep 3: feature-A のマージ # feature-Aの開発が完了したと仮定して、mainブランチにマージします。\n# 1. 元のワークツリー（mainブランチ）に移動します cd .. # 2. main ブランチにいることを確認します git branch # =\u0026gt; * main # 3. feature-A ブランチをマージします git merge feature-A git log --graph --oneline --all を実行すると、feature-Aがmainブランチにマージされた歴史を確認できます。\nStep 4: ワークツリーのクリーンアップ # 作業が完了したブランチのワークツリーは不要なので、削除してリポジトリを整理します。\n# ワークツリーの一覧を再度確認 git worktree list # 不要になったワークツリーを削除する # 注意: ワークツリー内に未コミットの変更が残っている場合、削除は失敗します。 # その場合は --force オプションで強制削除できます。 git worktree remove feature-a-worktree # .gitの管理情報から削除されるだけで、ディレクトリ自体は残るため手動で削除します rm -rf feature-a-worktree git worktree prune コマンドは、何らかの理由でディレクトリだけが先に削除されてしまった場合に、関連する管理情報をクリーンアップするのに役立ちます。\n3. まとめ # このハンズオンでは、以下のことを学びました。\ngit worktree add で新しいワークツリーとブランチを作成する方法 複数のワークツリー間を cd で自由に移動し、並行して作業を進める方法 作業が完了したワークツリーを git worktree remove で安全に削除する方法 git worktree を活用することで、ブランチの切り替えに伴う時間のかかるビルドや依存関係の再インストールといった手間を回避し、開発効率を劇的に向上させることができます。ぜひ、日々の開発に取り入れてみてください。\n4. コマンドリファレンス # # 指定したパスに新しいワークツリーを作成 # 同時に新しいブランチを作成してチェックアウトする git worktree add \u0026lt;path\u0026gt; -b \u0026lt;branch-name\u0026gt; # ワークツリーの一覧を表示 git worktree list # 指定したパスのワークツリーを削除 git worktree remove \u0026lt;path\u0026gt; # ワークツリーの管理情報をクリーンアップ git worktree prune 5. 参考リンク # Qiita：徹底解説：git worktree の使い方 git-worktree - Manage multiple working trees ","date":"2025年 8月 7日","externalUrl":null,"permalink":"/posts/git-worktree-hands-on/","section":"Posts","summary":"","title":"git worktree ハンズオン","type":"posts"},{"content":"","date":"2025年 8月 7日","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2025年 8月 7日","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025年 8月 7日","externalUrl":null,"permalink":"/","section":"技術的デジャブ回避メモ帳","summary":"","title":"技術的デジャブ回避メモ帳","type":"page"},{"content":"","date":"2025年 8月 3日","externalUrl":null,"permalink":"/tags/blowfish/","section":"Tags","summary":"","title":"Blowfish","type":"tags"},{"content":" はじめに # Blowfishではデフォルトで「フグ」のアイコンがfaviconとして設定されています。 デフォルトから自分好みのfaviconへ変更する手順を下記にまとめます。\n設定方法 # faviconの変更は、プロジェクトの static ディレクトリに独自の画像ファイルを配置するだけで完了します。\n. └── static/ ├─ android-chrome-192x192.png ├─ android-chrome-512x512.png ├─ apple-touch-icon.png ├─ favicon-16x16.png ├─ favicon-32x32.png ├─ favicon.ico └─ site.webmanifest これらのファイルと同じ名前で作成したご自身の画像を、プロジェクトのルートにある static フォルダに配置してください。 ファイルを配置した後、Hugoサーバーを再起動（またはビルド）すると、新しいfaviconがサイトに反d映されます。 hugo.tomlなどの設定ファイルでパスを記述する必要はありません。staticディレクトリに置かれたファイルが優先的に読み込まれる仕組みです。\n各ファイルの説明 # staticディレクトリに配置する各ファイルは、様々なデバイスや状況でサイトのアイコンを表示するために利用されます。\nfavicon.ico:\n用途: 最も伝統的なfavicon形式。主にPCブラウザのタブやブックマークで使われます。古いブラウザとの互換性のために重要です。 favicon-16x16.png / favicon-32x32.png:\n用途: 最新のPCブラウザが使用するPNG形式のfavicon。 16x16px: 標準的な解像度のディスプレイのブラウザタブに表示されます。 32x32px: Retinaディスプレイのような高解像度の画面や、タスクバーなどで使用されます。 apple-touch-icon.png:\n用途: iPhoneやiPadなど、Apple製品で「ホーム画面に追加」した際に表示されるアプリアイコンです。180x180pxが推奨サイズです。 android-chrome-192x192.png / android-chrome-512x512.png:\n用途: AndroidデバイスのChromeブラウザで「ホーム画面に追加」した際に使われます。 192x192px: ホーム画面のアイコンとして表示されます。 512x512px: サイト起動時のスプラッシュスクリーンに表示されることがあります。 site.webmanifest:\n用途: ウェブアプリマニフェストと呼ばれる設定ファイルです。サイト名やテーマカラー、そして上記のような各アイコンへのパスを定義し、ブラウザにどのアイコンを使うべきかを伝えます。 これらのファイルを揃えることで、あらゆる環境でサイトのアイコンが意図通りに表示されるようになります。\nfavicon作成に便利なサイト # favicon.io\n1つの画像から、主要なプラットフォーム向けのfavicon一式を生成してくれます。\nICOON MONO\n各種アイコン素材をダウンロードできます。\n参考リンク # Blowfish_favicon\n","date":"2025年 8月 3日","externalUrl":null,"permalink":"/posts/favicon_settings/","section":"Posts","summary":"","title":"BlowfishでFaviconを設定する方法","type":"posts"},{"content":"","date":"2025年 8月 3日","externalUrl":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo","type":"tags"},{"content":"","date":"2025年 8月 3日","externalUrl":null,"permalink":"/tags/github/","section":"Tags","summary":"","title":"Github","type":"tags"},{"content":" はじめに # 私は普段、Githubのプライベートリポジトリにメモやアイデアを書き溜めています。 リポジトリには、清書したメモなどを保管。Issuesに一時メモや作業メモをまとめています。 （IssuesについてはZennのスクラップと同じような感じで利用しています。） しかし、Issuesの作業メモなどは書き溜めた後、コピー\u0026amp;ペーストするような方法ばかりで、 効率的に活用できていませんでした。\nこの問題を解決するため、Issuesをmarkdownファイルとしてダウンロードして、ローカル環境で管理することを決めました。この記事では、GitHub CLIを使ってGitHubのIssuesをmarkdownファイルとしてダウンロードする方法を紹介します。\n最終的には下記コマンドを実行すればIssuesを取得することが可能です。\n# Issueの取得（jqコマンドで日時フォーマットを日本語表記に変換） gh issue view \u0026lt;ISSUE_NUMBER\u0026gt; --repo \u0026lt;OWNER/REPO\u0026gt; --comments --json comments | jq -r \u0026#39;.comments[] | \u0026#34;## コメント (\u0026#34; + (.createdAt | strptime(\u0026#34;%Y-%m-%dT%H:%M:%SZ\u0026#34;) | strftime(\u0026#34;%Y年%m月%d日 %H時%M分\u0026#34;)) + \u0026#34;)\\n\\n\u0026#34; + .body + \u0026#34;\\n\\n---\\n\u0026#34;\u0026#39; \u0026gt; \u0026lt;FILENAME\u0026gt;.md 対象読者：\nGithub CLIの基本的な使い方を知っている方 ドキュメント作成や記事執筆の素材としてIssuesを活用したい方 Isseusを取得する対象としてはプライベートリポジトリかつ、Githubの無料プランを利用しているユーザーを想定しております。\nパブリックリポジトリまたは有料プランユーザーの場合は、Github Wiki機能など互換性のある機能があるため、そちらを利用するほうが手順も簡単で、効率的にドキュメント運用できると考えられます。 前提条件\nOS: Linux（Ubuntu）環境（WSL2含む） 権限: GitHubにて対象リポジトリへのアクセス権限を保有している サンプル: 当記事ではサンプルリポジトリ（mr110825/gemini-cli-test-repo）を例として説明します 環境セットアップ # GitHub CLIのインストール # # インストール状況の確認 gh --version # GitHub CLIのインストール（必要な場合） sudo apt install gh GitHub CLIへのログイン # # ログイン状況の確認 gh auth status # GitHub CLIへログイン実行 gh auth login GitHub CLIへのログイン手順の詳細については、以下の記事をご参照ください。\n【Git のセットアップ】GitHub CLI を使って GitHub に接続する GitHub CLIのクイックスタート リポジトリのIssues一覧確認 # gh issue list --repo \u0026lt;OWNER/REPO\u0026gt; 実行例 # # サンプルのリポジトリ（mr110825/gemini-cli-test-repo）のIssueを対象とする gh issue list --repo mr110825/gemini-cli-test-repo 出力例 # ID TITLE LABELS UPDATED #1 サンプル用のIssues about 1 hour ago Issueの取得 # gh issue view \u0026lt;ISSUE_NUMBER\u0026gt; --repo \u0026lt;OWNER/REPO\u0026gt; --comments \u0026gt; \u0026lt;FILENAME\u0026gt;.md 実行例 # # サンプルのリポジトリ（mr110825/gemini-cli-test-repo）のIssues#1を「test1.md」として取得する gh issue view 1 --repo mr110825/gemini-cli-test-repo --comments \u0026gt; test1.md 出力例 # author:\tmr110825 association:\towner edited:\ttrue status:\tnone -- 記事を投稿するので構成をまとめる -- author:\tmr110825 association:\towner edited:\ttrue status:\tnone -- 必要な手順 - [x] 文章企画を構成 - [x] サンプルのリポジトリを作成 - [x] 記事作成 - [x] 記事投稿 -- この方法は最もシンプルですが、出力されるファイルには多くのメタデータが含まれており、実際の内容を読みにくく感じました。\n特に、複数のコメントがある場合、どのコメントがどのタイミングで投稿されたのかが分かりにくいという問題があります。 Issueの取得（不要なプロパティを除外してISO形式でコメントのみを取得） # gh issue view \u0026lt;ISSUE_NUMBER\u0026gt; --repo \u0026lt;OWNER/REPO\u0026gt; --comments --json comments --template \u0026#39;{{range .comments}}## コメント ({{.createdAt}}) {{.body}} --- {{end}}\u0026#39; \u0026gt; \u0026lt;FILENAME\u0026gt;.md 実行例 # # サンプルのリポジトリ（mr110825/gemini-cli-test-repo）のIssues#1を「test2.md」として取得する gh issue view 1 --repo mr110825/gemini-cli-test-repo --comments --json comments --template \u0026#39;{{range .comments}}## コメント ({{.createdAt}}) {{.body}} --- {{end}}\u0026#39; \u0026gt; test2.md 出力例 # ## コメント (2025-06-28T12:24:28Z) 記事を投稿するので構成をまとめる --- ## コメント (2025-06-28T12:25:50Z) 必要な手順 - [x] 文章企画を構成 - [x] サンプルのリポジトリを作成 - [x] 記事作成 - [x] 記事投稿 --- この方法では、メタデータが除去され、コメントの内容と投稿日時が明確に表示されるようになりました。\nしかし、ISO形式の日時表記は読みづらいため、さらに改善が必要です。 Issueの取得（jqコマンドで日時フォーマットを日本語表記に変換） # gh issue view \u0026lt;ISSUE_NUMBER\u0026gt; --repo \u0026lt;OWNER/REPO\u0026gt; --comments --json comments | jq -r \u0026#39;.comments[] | \u0026#34;## コメント (\u0026#34; + (.createdAt | strptime(\u0026#34;%Y-%m-%dT%H:%M:%SZ\u0026#34;) | strftime(\u0026#34;%Y年%m月%d日 %H時%M分\u0026#34;)) + \u0026#34;)\\n\\n\u0026#34; + .body + \u0026#34;\\n\\n---\\n\u0026#34;\u0026#39; \u0026gt; \u0026lt;FILENAME\u0026gt;.md # jqコマンドのインストール（必要な場合） sudo apt install jq 実行例 # # サンプルのリポジトリ（mr110825/gemini-cli-test-repo）のIssues#1を「test3.md」として取得する gh issue view 1 --repo mr110825/gemini-cli-test-repo --comments --json comments | jq -r \u0026#39;.comments[] | \u0026#34;## コメント (\u0026#34; + (.createdAt | strptime(\u0026#34;%Y-%m-%dT%H:%M:%SZ\u0026#34;) | strftime(\u0026#34;%Y年%m月%d日 %H時%M分\u0026#34;)) + \u0026#34;)\\n\\n\u0026#34; + .body + \u0026#34;\\n\\n---\\n\u0026#34;\u0026#39; \u0026gt; test3.md 出力例 # ## コメント (2025年06月28日 12時24分) 記事を投稿するので構成をまとめる --- ## コメント (2025年06月28日 12時25分) 必要な手順 - [x] 文章企画を構成 - [x] サンプルのリポジトリを作成 - [x] 記事作成 - [x] 記事投稿 --- この方法が最も実用的です。日本語表記により、日時が直感的に理解でき、ドキュメントとして保存した際にも読みやすくなります。ただし、jqコマンドのインストールが必要になるため、環境によっては追加のセットアップが必要になります。 コマンドリファレンス # # Issues一覧確認 gh issue list --repo \u0026lt;OWNER/REPO\u0026gt; # Issueの取得 gh issue view \u0026lt;ISSUE_NUMBER\u0026gt; --repo \u0026lt;OWNER/REPO\u0026gt; --comments \u0026gt; \u0026lt;FILENAME\u0026gt;.md # Issueの取得（不要なプロパティを除外してISO形式でコメントのみを取得） gh issue view \u0026lt;ISSUE_NUMBER\u0026gt; --repo \u0026lt;OWNER/REPO\u0026gt; --comments --json comments --template \u0026#39;{{range .comments}}## コメント ({{.createdAt}}) {{.body}} --- {{end}}\u0026#39; \u0026gt; \u0026lt;FILENAME\u0026gt;.md # Issueの取得（jqコマンドで日時フォーマットを日本語表記に変換） gh issue view \u0026lt;ISSUE_NUMBER\u0026gt; --repo \u0026lt;OWNER/REPO\u0026gt; --comments --json comments | jq -r \u0026#39;.comments[] | \u0026#34;## コメント (\u0026#34; + (.createdAt | strptime(\u0026#34;%Y-%m-%dT%H:%M:%SZ\u0026#34;) | strftime(\u0026#34;%Y年%m月%d日 %H時%M分\u0026#34;)) + \u0026#34;)\\n\\n\u0026#34; + .body + \u0026#34;\\n\\n---\\n\u0026#34;\u0026#39; \u0026gt; \u0026lt;FILENAME\u0026gt;.md まとめ # Github CLIを使用してIssuesをMarkdownファイルとしてダウンロードする方法を紹介しました。特に、jqコマンドを使用した日本語表記でのダウンロード方法が、実用的で読みやすい結果を得られると感じています。\nこの方法により、オフライン環境でもIssuesの内容を参照でき、ドキュメント作成や記事執筆の素材としても活用できるようになります。実際に使用してみて、いくつかの改善点も見つかりましたが、基本的なニーズを満たすには十分な方法だと思います。\n","date":"2025年 8月 3日","externalUrl":null,"permalink":"/posts/how_to_download_github_issues/","section":"Posts","summary":"","title":"Github CLIでIssuesをMarkdownファイルとしてダウンロードする方法","type":"posts"}]