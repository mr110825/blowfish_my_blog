
[{"content":"","date":"2025年 9月 7日","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"","date":"2025年 9月 7日","externalUrl":null,"permalink":"/scraps/","section":"Scraps","summary":"","title":"Scraps","type":"scraps"},{"content":"","date":"2025年 9月 7日","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025年 9月 7日","externalUrl":null,"permalink":"/","section":"技術的デジャブ回避メモ帳","summary":"","title":"技術的デジャブ回避メモ帳","type":"page"},{"content":"","date":"2025年 9月 7日","externalUrl":null,"permalink":"/tags/%E5%8B%89%E5%BC%B7%E3%83%A1%E3%83%A2/","section":"Tags","summary":"","title":"勉強メモ","type":"tags"},{"content":" はじめに # Pandasは、Pythonでデータを扱う際によく用いられるライブラリであり、データ操作に特化しています。データ分析や機械学習プロジェクトにおけるデータ整理、加工、分析の基礎を築く上で非常に便利です。\n以下に、Pandasライブラリの主要なデータ操作機能とその実用的な活用方法を説明します。\n1. データの読み込みと確認 # CSVファイルの読み込み: pd.read_csv()メソッドを使用して、CSVファイルをデータフレーム（df）として読み込むことができます。これにより、外部の表形式データをPythonで扱えるようになります。 データフレームの内容確認: df.head(n): データフレームの先頭からn行を表示します。通常、データフレーム全体を見ることはないため、データの概要を素早く把握するのに役立ちます。 df.tail(n): データフレームの末尾からn行を表示します。データが時系列順に並んでいる場合など、最新のデータを確認する際に便利です。 2. データの前処理（整形・クリーニング） # データ分析において、生データはしばしば不要な情報や不備を含んでいます。これらを整形・クリーニングすることで、データの品質を高め、分析に適した形に整えます。\n不要な行・列の削除（必要な部分の抽出）: 特定の列を抽出することで、不要な列を実質的に削除できます。これは、データフレームの df[カラム名のリスト] の形式で実現できます。例えば、単位情報や重複した情報を含むカラムなどを削除する際に用います。 特定の行を抽出することで、不要な行を実質的に削除できます。例えば、先頭行が不要なラベル情報である場合、df[1:] のように指定して2行目以降のデータを抽出します。 カラム名の変更: df.columns = [新しいカラム名のリスト] を使用すると、データフレームの全てのカラム名を一度に変更できます。例えば、カラム名に含まれる単位などの不要な部分を一括で削除し、短く分かりやすい名前に変更する際に有効です。 df.rename(columns={'変更前': '変更後'}) メソッドを使用すると、特定のカラム名のみをピンポイントで変更できます。これは、多くのカラムがある中で一部だけ変更したい場合に便利です。ただし、df自体の中身は変わらないため、変更を永続化するには再度代入 (df = df.rename(...)) が必要です。 欠損値の処理: 欠損値の確認: df.isnull() を使用すると、データフレーム内の各要素が欠損値（NaN）であるかどうかがTrue/Falseで判定されます。さらに、.sum() を組み合わせることで、各カラムにいくつ欠損値があるかを確認できます。これは、データ品質の問題を特定する上で重要です。 欠損値の補完: df.fillna(値) メソッドは、データフレーム内の欠損値を指定した値で埋めます。例えば、欠損値を0で埋めることができます。実際には、データの性質に応じて中央値や平均値といった統計量で補完することが多いです。 欠損値の削除: df.dropna(axis=値) メソッドは、欠損値を含む行または列を削除します。axis=1 を指定すると列方向に、axis=0 を指定すると行方向に削除されます。データ分析において、特にデータ数が少ないカラムや、その列全体が欠損値である場合に、その列を削除することでノイズを減らすことができます。 重複の除去: df.drop_duplicates(subset='カラム名') メソッドを使用すると、指定したカラム（subset）において重複する行を削除し、ユニークな行のみを残すことができます。subsetを指定しない場合、全てのカラムが一致する行が削除されます。 データ型の確認: df.dtypes を使用すると、データフレームの各カラムのデータ型を確認できます。これにより、データが意図した型で格納されているか、前処理が必要か（例: 文字列型の日付を日付型に変換するなど）を判断できます。 ダミー変数への変換: pd.get_dummies(df, columns=['カラム名']) メソッドは、カテゴリカルなデータを機械学習モデルで扱える数値データ（0または1）に変換するダミー変数化を行います。例えば、「国籍」のようなカテゴリカルな列を、「国籍_日本」「国籍_アメリカ」といった0/1の列に変換します。 3. データの抽出と選択 # データフレームから特定の条件を満たすデータや、特定の範囲のデータを柔軟に選択・抽出する機能です。\n任意の要素の取得 (iloc, loc): df.iloc[行インデックス, 列インデックス] は、インデックス番号（0から始まる位置）で指定して要素を抽出します。 df.loc[行ラベル, 列ラベル] は、**行や列のラベル名（カラム名）**で指定して要素を抽出します。 これらは、データフレーム内の特定の部分をピンポイントで取得したい場合に非常に強力なツールです。 条件抽出: 特定の条件を満たす行を抽出するには、データフレームに対して直接条件式（例: df[df['カラム名'] == '値']）を適用する方法が一般的です。複数の条件を組み合わせる場合は \u0026amp; (and) や | (or) で連結し、各条件を括弧で囲みます。 df.query('カラム名 == \u0026quot;値\u0026quot;') メソッドは、文字列形式で条件式を記述することで抽出を行います。 df['カラム名'].isin(['値1', '値2']) メソッドは、指定した値のリストに含まれる要素を持つ行を抽出する際に便利です。 これらは、特定の条件（例: 「アメリカ国籍の20歳以上30歳未満の人物」など）に合致するデータを絞り込みたい場合に活用されます。 4. データの集計と分析 # データから意味のある情報を導き出すための集計や統計分析を行う機能です。\nユニークな値と出現回数の確認: df['カラム名'].unique() メソッドは、指定したカラムに含まれるユニークな（重複しない）値のリストを取得します。 df['カラム名'].value_counts() メソッドは、指定したカラムのユニークな値とその出現回数を一覧で表示します。これは、カテゴリカルデータの分布を理解する上で非常に役立ちます。 グループごとの集計: df.groupby('グループ化したいカラム名').mean() のように groupby() メソッドを使用すると、指定したカラムのカテゴリごとにデータをグループ化し、それぞれのグループで平均値（mean()）などの統計量を算出できます。これにより、カテゴリ間の比較分析が容易になります。 統計量の確認: df.mean(), df.median(), df.std(), df.max(), df.min() などを使用すると、データフレームの各カラムの平均値、中央値、標準偏差、最大値、最小値といった基本的な統計量を個別に算出できます。 df.describe() メソッドは、これらの主要な統計量を一括で表形式で出力します。データの全体的な特性を素早く把握する際に非常に便利です。 データの並び替え: df.sort_values(by='カラム名', ascending=False) メソッドは、指定したカラムの値に基づいてデータフレームの行を並び替えます。ascending=False を設定すると降順（高い順）に、True（デフォルト）だと昇順（低い順）に並び替えることができます。 相関係数の算出: df.corr() メソッドは、データフレーム内の数値型カラム間の相関係数を算出します。相関係数は、二つの値がどれだけ関係性があるかを示す指標で、正の相関（一方が増えれば他方も増える）は1に近く、負の相関（一方が増えれば他方が減る）は-1に近く、無相関は0に近くなります。これにより、変数間の関係性を数値で把握できます。 5. データの可視化と出力 # 分析結果を視覚的に表現し、また加工したデータを再利用可能な形式で保存します。\nグラフ表示（可視化）: Pandasのデータフレームは、matplotlibライブラリと連携して直接グラフを描画する機能を持っています。例えば、df.plot(x='横軸カラム名', y=['縦軸カラム名1', '縦軸カラム名2'], kind='line', legend=False) のように指定することで、折れ線グラフなどを表示できます。データの特徴やトレンドを直感的に理解するために不可欠な機能です。ただし、日本語フォントの設定を行わないと文字化けすることがあります。 データ出力: df.to_csv('ファイル名.csv', index=False) メソッドは、加工済みのデータフレームをCSVファイルとして出力します。index=False を指定すると、データフレームのインデックス（左側の数値）は出力されません。これにより、クリーンアップまたは分析されたデータを他のツールやプロジェクトで再利用できます。 これらの機能を活用することで、データの読み込みから、前処理、分析、可視化、出力までの一連のデータ操作を効率的に行うことができます。\nYouTubeチャンネル「いまにゅのプログラミング塾」の動画「【Pandas徹底講座】この動画1本でデータ操作に特化したPythonライブラリPandasの基礎をマスター！」で出題された20問のハンズオンについて、それぞれの概要と解説を以下にまとめます。この講座は、データ整理、加工、分析の基礎を固める上で非常に実用的な内容となっています。\nPandasハンズオン 20問 解説 # 1. データの読み込み # 概要: weather.csvファイルを読み込み、dfというデータフレームとして定義する。 解説: Pandasライブラリをpdとしてインポートした後、pd.read_csv() メソッドを使用してCSVファイルを読み込みます。ファイル名を作業ディレクトリ内に指定するだけで読み込みが可能です。 import pandas as pd df = pd.read_csv(\u0026#39;weather.csv\u0026#39;) print(df) 2. データの中身確認 # 概要: 読み込んだデータフレームdfの先頭3行と末尾10行を表示する。 解説: データフレーム全体を見ることは稀であるため、データの概要を把握する際に使います。 df.head(n): データフレームの先頭からn行を表示します（n=3）。 df.tail(n): データフレームの末尾からn行を表示します（n=10）。 import pandas as pd df = pd.read_csv(\u0026#39;weather.csv\u0026#39;) print(df.head(3)) print(df.tail(10)) 3. 不要な列・行の削除 # 概要: データフレームから不要な先頭行（ラベル情報など）と、特定の不要な列（例: 平均気温.1、平均気温.2のように「.数字」が付く列）を削除し、dfとして再定義する。 解説: 一般的なdropメソッドではなく、必要な部分のみを抽出するアプローチが推奨されています。 列の抽出: 必要なカラム名のみをリストで指定し、df[カラム名のリスト]の形式で抽出します。 行の抽出: 先頭行が不要な場合、df[1:]のようにスライス表記を用いて2行目以降のデータを抽出します。 # ラベル情報を抽出 import pandas as pd df = pd.read_csv(\u0026#39;weather.csv\u0026#39;) print(df.columns) # 必要なラベルを抽出して表示させる df = df[[ \u0026#39;年月日\u0026#39;, \u0026#39;平均気温(℃)\u0026#39;, \u0026#39;最高気温(℃)\u0026#39;, \u0026#39;最低気温(℃)\u0026#39;, \u0026#39;降水量の合計(mm)\u0026#39;, \u0026#39;最深積雪(cm)\u0026#39;, \u0026#39;平均雲量(10分比)\u0026#39;, \u0026#39;平均蒸気圧(hPa)\u0026#39;, \u0026#39;平均風速(m/s)\u0026#39;, \u0026#39;日照時間(時間)\u0026#39;, ]] print(df) # 1行目から取得する場合 df = df[[ \u0026#39;年月日\u0026#39;, \u0026#39;平均気温(℃)\u0026#39;, \u0026#39;最高気温(℃)\u0026#39;, \u0026#39;最低気温(℃)\u0026#39;, \u0026#39;降水量の合計(mm)\u0026#39;, \u0026#39;最深積雪(cm)\u0026#39;, \u0026#39;平均雲量(10分比)\u0026#39;, \u0026#39;平均蒸気圧(hPa)\u0026#39;, \u0026#39;平均風速(m/s)\u0026#39;, \u0026#39;日照時間(時間)\u0026#39; ]][1:] print(df) 4. データの形・サイズ、列名・行名、データ型の確認 # 概要: 各列のデータ型、データフレームのサイズ（行数・列数）、列名（カラム名）、行名（インデックス）を取得する。 解説: データ型: df.dtypes を使用し、各カラムのデータ型（数値型、オブジェクト型など）を確認します。 サイズ: df.shape を使用し、データフレームの行数と列数を(行数, 列数)のタプル形式で取得します。 列名: df.columns を使用し、データフレームのカラム名リストを取得します。 行名（インデックス）: df.index を使用し、行のインデックス情報を取得します。現在のインデックスが数値であれば、その範囲と刻みが表示されます。 print(df.dtypes) print(df.shape) print(df.columns) print(df.index) 5. 任意の要素の取得 # 概要: dfの5行目から10行目まで、かつ3列目から6列目まで（最高気温から最深積雪まで）の要素を取得する。 解説: 特定の範囲のデータにアクセスするために、主に以下の2つの方法があります。 df.iloc[行インデックス, 列インデックス]: インデックス番号（0から始まる位置）で要素を抽出します。例えば、5行目から10行目（インデックス4から9）は4:10、3列目から6列目（インデックス2から5）は2:6と指定します。 df.loc[行ラベル, 列ラベル]: **行ラベル名や列ラベル名（カラム名）**で要素を抽出します。行は5:10のように指定し、列は'最高気温':'最深積雪'のように範囲で指定します。locの行の範囲指定は終端を含みますが、ilocは含みません。 import pandas as pd df = pd.read_csv(\u0026#39;weather.csv\u0026#39;) print(df.iloc[4:10, 2:6]) print(df.loc[5:10,\u0026#39;最高気温(℃)\u0026#39;:\u0026#39;最深積雪(cm)\u0026#39;]) 6. 条件抽出 # 概要: people.csvをdf_peopleとして読み込み、以下の条件を満たすデータを抽出する。 Nationalityが「America」であるもの。 Ageが20以上30未満であるもの。 解説: 直接的な条件式: df_people[df_people['Nationality'] == 'America'] のように、データフレームに対して直接条件式を適用する方法がよく使われます。複数の条件を組み合わせる場合は、各条件を括弧で囲み、\u0026amp;（AND）や|（OR）で連結します（例: (df['Age'] \u0026gt;= 20) \u0026amp; (df['Age'] \u0026lt; 30)）。 df.query() メソッド: df_people.query('Nationality == \u0026quot;America\u0026quot;') のように、文字列形式で条件式を記述して抽出することもできます。 df['カラム名'].isin([]) メソッド: 指定した値のリストに含まれる要素を持つ行を抽出する際に便利です（例: df_people['Nationality'].isin(['America'])）。 import pandas as pd df_people = pd.read_csv(\u0026#39;people.csv\u0026#39;) # n条件に合致したものがTrueとなり、Trueのみ表示させる print(df_people[df_people[\u0026#39;nationality\u0026#39;] == \u0026#39;America\u0026#39;]) print(df_people[(df_people[\u0026#39;age\u0026#39;] \u0026gt;= 20) \u0026amp; (df_people[\u0026#39;age\u0026#39;] \u0026lt; 30)]) # こちらはクエリを利用した方法 print(df_people.query(\u0026#39;nationality == \u0026#34;America\u0026#34;\u0026#39;)) # isinを利用した方法 print(df_people[df_people[\u0026#39;nationality\u0026#39;].isin([\u0026#39;America\u0026#39;])]) 7. ユニークな値の抽出 # 概要: df_peopleの各カラムについて、ユニークな（固有の）値を抽出する。 解説: df['カラム名'].unique() メソッドを使用します。このメソッドはシリーズ（1次元データ）にしか適用できないため、データフレーム全体に直接適用するとエラーになることに注意が必要です。 import pandas as pd df_people = pd.read_csv(\u0026#39;people.csv\u0026#39;) print(df_people[\u0026#39;nationality\u0026#39;].unique()) print(df_people[\u0026#39;name\u0026#39;].unique()) print(df_people[\u0026#39;age\u0026#39;].unique()) 8. 重複除去 # 概要: df_peopleのNationality列において、重複する値を持つ行を削除し、重複がないデータフレームを取得する。 解説: df.drop_duplicates(subset='カラム名') メソッドを使用します。 subset引数を指定しない場合、すべてのカラムの値が一致する行が重複とみなされます。 subset='Nationality'のように特定のカラム名を指定すると、そのカラムの値が重複する場合に該当する行を削除します。 import pandas as pd df_people = pd.read_csv(\u0026#39;people.csv\u0026#39;) print(df_people.drop_duplicates(subset=\u0026#39;nationality\u0026#39;)) 9. カラム名変更 # 概要: dfの各カラム名から、単位部分（例: (℃)、(mm)）を削除する。 解説: カラム名を変更する方法はいくつかあります。 一括変更: df.columns = [新しいカラム名のリスト] を使用し、すべてのカラム名を新しいリストで上書きします。これはカラム数が少ない場合に手動でリストを作成するのに便利です。 df.rename() メソッド: df.rename(columns={'変更前':'変更後'}) を使用すると、特定のカラム名のみをピンポイントで変更できます。df.rename()はデフォルトではデータフレーム自体を直接変更しないため、変更を永続化するには df = df.rename(...) のように再代入が必要です。 import pandas as pd df = pd.read_csv(\u0026#39;weather.csv\u0026#39;) df.columns = [ \u0026#39;年月日\u0026#39;, \u0026#39;平均気温(℃)\u0026#39;, \u0026#39;最高気温(℃)\u0026#39;, \u0026#39;最低気温(℃)\u0026#39;, \u0026#39;降水量の合計(mm)\u0026#39;, \u0026#39;最深積雪(cm)\u0026#39;, \u0026#39;平均雲量(10分比)\u0026#39;, \u0026#39;平均蒸気圧(hPa)\u0026#39;, \u0026#39;平均風速(m/s)\u0026#39;, \u0026#39;日照時間(時間)\u0026#39; ] df.rename(columns={ \u0026#39;平均気温\u0026#39;:\u0026#39;平均\u0026#39; }) 10. 並び替え # 概要: dfを最高気温が高い順（降順）に並び替える。 解説: df.sort_values(by='カラム名', ascending=False) メソッドを使用します。 by引数で並び替えの基準となるカラムを指定します。 ascending=Falseを指定すると降順（高い順）に並び替えます。True（デフォルト）だと昇順（低い順）になります。 import pandas as pd df = pd.read_csv(\u0026#39;weather.csv\u0026#39;) print(df.sort_values(\u0026#39;最高気温(℃)\u0026#39;)) print(df.sort_values(\u0026#39;最高気温(℃)\u0026#39;,ascending=False)) 11. ダミー変数への処理 # 概要: df_peopleのNationalityカラムをダミー変数に変換する。 解説: カテゴリカルなデータを0または1で表現するダミー変数化には pd.get_dummies() メソッドを使用します。 pd.get_dummies(df, columns=['カラム名']) のように、変換したいデータフレームとカラム名を指定することで、指定したカラムのみをダミー変数化し、元のデータフレームに結合された形で取得できます。 import pandas as pd df_people = pd.read_csv(\u0026#39;people.csv\u0026#39;) df_people_dummy = pd.get_dummies(df_people, columns=[\u0026#39;nationality\u0026#39;]) print(df_people_dummy) 12. 欠損値の確認 # 概要: df内の欠損値（値が入っていない要素）を確認する。 解説: df.isnull() メソッドを使用します。これは、各要素が欠損値であればTrue、そうでなければFalseとなるブール型のデータフレームを返します。さらに、.sum()を組み合わせることで、各カラムの欠損値の合計数を簡単に確認できます（例: df.isnull().sum()）。 import pandas as pd df = pd.read_csv(\u0026#39;weather.csv\u0026#39;) print(df.isnull().sum()) 13. 欠損値の補完 # 概要: dfの欠損値をすべて0で補完（埋める）する。 解説: df.fillna(値) メソッドを使用します。このメソッドの引数に0を指定することで、すべての欠損値が0で埋められます。実用上は、中央値や平均値などの統計量で補完することが多いです。 import pandas as pd df = pd.read_csv(\u0026#39;weather.csv\u0026#39;) df = df.fillna(0) print(df.isnull().sum()) 14. 欠損値の削除 # 概要: dfの欠損値を含む列を削除する。 解説: df.dropna(axis=値) メソッドを使用します。 axis=1: 列方向（カラム全体）に欠損値が存在する場合、その列を削除します。 axis=0（デフォルト）: 行方向（行全体）に欠損値が存在する場合、その行を削除します。 今回のケースでは、一部の列がほとんど（またはすべて）欠損値であったため、行を削除するとほとんどのデータが失われるため、列方向の削除が適切でした。df = df.dropna(...)のように再代入しないと、データフレーム自体は変更されません。 import pandas as pd df = pd.read_csv(\u0026#39;weather.csv\u0026#39;) df = df.dropna(axis=1) print(df) 15. ユニークな値と出現回数 # 概要: iris.csvをdf_irisとして読み込み、Classカラムのユニークな値とそれぞれの出現回数を確認する。 解説: df['カラム名'].value_counts() メソッドを使用します。これはシリーズに適用され、ユニークな値とその出現回数を高い順に表示します。 import pandas as pd df_iris = pd.read_csv(\u0026#39;iris.csv\u0026#39;) print(df_iris[\u0026#39;Class\u0026#39;].value_counts()) 16. グループごとの集計 # 概要: df_irisの各Class（Iris-setosa、Iris-versicolor、Iris-virginica）におけるSepal Length、Sepal Width、Petal Length、Petal Widthの平均値を求める。 解説: df.groupby('グループ化したいカラム名').mean() のように、groupby()メソッドと集計メソッドを組み合わせます。groupby()で指定したカラム（例: Class）のカテゴリごとにデータをグループ化し、そのグループに対して平均値（mean()）などの統計量を算出できます。mean()以外にもstd()（標準偏差）などが適用可能です。 import pandas as pd df_iris = pd.read_csv(\u0026#39;iris.csv\u0026#39;) print(df_iris.groupby(\u0026#39;Class\u0026#39;).mean()) 17. 統計量の確認 # 概要: df_irisの各カラムについて、平均値、中央値、標準偏差、最大値、最小値を算出する。 解説: 個別の統計量: df.mean()、df.median()、df.std()、df.max()、df.min() など、各統計量に対応するメソッドを直接呼び出すことができます。 一括統計量: df.describe() メソッドは、これらの主要な統計量（カウント、平均、標準偏差、最小値、25パーセンタイル、中央値、75パーセンタイル、最大値）をまとめて表形式で出力し、データの全体像を素早く把握するのに非常に便利です。 import pandas as pd df_iris = pd.read_csv(\u0026#39;iris.csv\u0026#39;) # df_irisのClass列は文字列なので、数値計算の対象外にする print(df_iris.drop(columns=[\u0026#39;Class\u0026#39;]).mean()) print(df_iris.drop(columns=[\u0026#39;Class\u0026#39;]).median()) print(df_iris.drop(columns=[\u0026#39;Class\u0026#39;]).std()) print(df_iris.drop(columns=[\u0026#39;Class\u0026#39;]).max()) print(df_iris.drop(columns=[\u0026#39;Class\u0026#39;]).min()) print(df_iris.describe()) 18. 折れ線グラフの表示 # 概要: dfの最初の50日間のデータにおける平均気温、最高気温、最低気温を折れ線グラフで可視化する。横軸は年月とし、判例は表示しない。 解説: Pandasのデータフレームはmatplotlibと連携してグラフを描画できます。 matplotlib.pyplotをpltとしてインポートします。 データの最初の50行を抽出し（例: df[:50]）、そのデータフレームに対して df.plot(x='横軸カラム名', y=['縦軸カラム名1', '縦軸カラム名2'], kind='line', legend=False) メソッドを使用します。 kind='line'で折れ線グラフを指定し、legend=Falseで判例を非表示にします。日本語の文字化けが発生する可能性があるため、その場合はmatplotlibの日本語フォント設定が必要です。 import pandas as pd import matplotlib.pyplot as plt df = pd.read_csv(\u0026#39;weather.csv\u0026#39;) df = df[1:51] # 1行目から50行目まで # 日本語の文字化け対策（環境に合わせてフォントを指定） # plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;Hiragino Maru Gothic Pro\u0026#39;] df.plot(x=\u0026#39;年月日\u0026#39;, y=[\u0026#39;平均気温(℃)\u0026#39;, \u0026#39;最高気温(℃)\u0026#39;, \u0026#39;最低気温(℃)\u0026#39;], kind=\u0026#39;line\u0026#39;, legend=False) plt.show() 19. 相関係数の算出 # 概要: dfの平均気温、降水量の合計、日照時間の3項目における相関係数を算出する。 解説: df.corr() メソッドを使用します。 相関係数は、2つの変数間の関係性の強さを示す指標で、-1から1の間の値を取ります。 1に近いほど強い正の相関（一方が増えれば他方も増える）、-1に近いほど強い負の相関（一方が増えれば他方が減る）、0に近いほど相関がないことを示します。 特定の列の相関を見る場合は、それらの列を抽出したデータフレームに対してcorr()を適用します。データフレーム全体に適用すると、すべての数値型カラム間の相関係数を計算します。 import pandas as pd df = pd.read_csv(\u0026#39;weather.csv\u0026#39;) df = df[1:] # データ型を数値に変換 df[\u0026#39;平均気温(℃)\u0026#39;] = pd.to_numeric(df[\u0026#39;平均気温(℃)\u0026#39;], errors=\u0026#39;coerce\u0026#39;) df[\u0026#39;降水量の合計(mm)\u0026#39;] = pd.to_numeric(df[\u0026#39;降水量の合計(mm)\u0026#39;], errors=\u0026#39;coerce\u0026#39;) df[\u0026#39;日照時間(時間)\u0026#39;] = pd.to_numeric(df[\u0026#39;日照時間(時間)\u0026#39;], errors=\u0026#39;coerce\u0026#39;) print(df[[\u0026#39;平均気温(℃)\u0026#39;, \u0026#39;降水量の合計(mm)\u0026#39;, \u0026#39;日照時間(時間)\u0026#39;]].corr()) 20. データの出力 # 概要: 欠損値を0で補完したdfをexport.csvというファイル名でCSVファイルとして出力する。この際、データフレームのインデックスは出力しない。 解説: df.to_csv('ファイル名.csv', index=False) メソッドを使用します。 第一引数に出力するファイル名を指定します。 index=Falseを指定することで、データフレームのインデックス番号がCSVファイルに出力されないようにします。 import pandas as pd df = pd.read_csv(\u0026#39;weather.csv\u0026#39;) df = df.fillna(0) df.to_csv(\u0026#39;export.csv\u0026#39;, index=False) 参考リンク # 【Pandas徹底講座】この動画1本でデータ操作に特化したPythonライブラリPandasの基礎をマスター！\n","date":"2025年 9月 7日","externalUrl":null,"permalink":"/scraps/study-pandas/","section":"Scraps","summary":"","title":"勉強メモ：Pandas","type":"scraps"},{"content":" 九九の段を出力 # 1×1 ～ 9×9 の九九の段を出力するプログラムを書いてください。\n各行の末尾に「○の段です」と表示しましょう。\n1 2 3 4 5 6 7 8 9 「1」の段です 2 4 6 8 10 12 14 16 18 「2」の段です ... 9 18 27 36 45 54 63 72 81 「9」の段です for ループを2つ使う（二重ループ）ことで、九九のような表を作成できます。内側のループが列、外側のループが行を処理します。\n回答 for i in range(1, 10): for j in range(1, 10): print(i * j, end=\u0026#34; \u0026#34;) print(\u0026#34;「{}」の段です\u0026#34;.format(i)) 3の倍数ならfoo、そうでなければnoo # ユーザーから1つ数字を入力し、それが「3の倍数」であれば foo、そうでなければ noo と出力してください。\n数字を入力してください: 9 foo % 演算子は、割り算の余りを求めます。num % 3 == 0 のように、3で割った余りが0になるかどうかで、3の倍数を判定できます。\n回答 num = int(input(\u0026#34;数字を入力してください: \u0026#34;)) if num % 3 == 0: print(\u0026#34;foo\u0026#34;) else: print(\u0026#34;noo\u0026#34;) 2つの数字の和を計算しよう # ユーザーから2つの数字を受け取り、その和を出力してください。\n1つ目の数字: 3 2つ目の数字: 5 合計: 8 input() で受け取った文字列を int() で整数に変換してから、足し算を行います。\n回答 x = int(input(\u0026#34;1つ目の数字: \u0026#34;)) y = int(input(\u0026#34;2つ目の数字: \u0026#34;)) print(\u0026#34;合計:\u0026#34;, x + y) 値を入れ替えてみよう # ユーザーから数字を2つ入力し、入れ替えて表示しましょう。\n出力の書式は print(\u0026quot;i =\u0026quot;, i, \u0026quot;, j =\u0026quot;, j) を必ず使ってください。\ni = 1 , j = 2 i = 2 , j = 1 Pythonでは i, j = j, i のように、1行で複数の変数の値を簡単に入れ替えることができます。\n回答 i = input(\u0026#34;iを入力: \u0026#34;) j = input(\u0026#34;jを入力: \u0026#34;) print(\u0026#34;i =\u0026#34;, i, \u0026#34;, j =\u0026#34;, j) i, j = j, i print(\u0026#34;i =\u0026#34;, i, \u0026#34;, j =\u0026#34;, j) 三角形を描いてみよう # ユーザーから高さを入力し、その高さの直角三角形を「*」で描いてください。\n# 出力例（高さ=5） * ** *** **** ***** 文字列に * 演算子を使うと、その文字列を指定した回数だけ繰り返します。\u0026quot;*\u0026quot; * 5 は ***** となります。\n回答 h = int(input(\u0026#34;高さを入力してください: \u0026#34;)) for i in range(1, h+1): print(\u0026#34;*\u0026#34; * i) 素数の和を求めよう # 20000 以下の素数をすべて足し算してください。\n21171191 素数とは、1とその数自身以外に約数を持たない自然数のことです。ある数 i が素数かどうかは、2から i の平方根までの数で割り切れるかどうかで判定できます。\n回答 sum_num = 0 for i in range(2, 20001): for j in range(2, int(i ** 0.5) + 1): if i % j == 0: break else: sum_num += i print(sum_num) 数字を連続で入力してカウントしよう # ユーザーから10回数を入力し、同じ数が連続で入力された回数をカウントしてください。\n10回連続なら perfect!! と表示しましょう。\n数字を入力してください: 1 連続なし 数字を入力してください: 1 2回連続 数字を入力してください: 1 3回連続 ... 1つ前の入力値を prev のような変数に保存しておくことで、現在の入力値と比較して連続しているかどうかを判定できます。\n回答 prev = None count = 1 for i in range(10): num = int(input(\u0026#34;数字を入力してください: \u0026#34;)) if num == prev: count += 1 print(\u0026#34;{}回連続\u0026#34;.format(count)) if count == 10: print(\u0026#34;perfect!!\u0026#34;) else: count = 1 print(\u0026#34;連続なし\u0026#34;) prev = num 数字の中に「5」があるか探そう # 入力された数字を1桁ずつ調べて「5」が含まれるかを出力してください。\n12345 5じゃないです 5じゃないです 5じゃないです 5じゃないです 5です!! input() で受け取った値は文字列なので、for ループで1文字ずつ取り出して調べることができます。\n回答 x = input(\u0026#34;数字を入力してください: \u0026#34;) for i in x: if i == \u0026#34;5\u0026#34;: print(\u0026#34;5です!!\u0026#34;) else: print(\u0026#34;5じゃないです\u0026#34;) 足し算と引き算をしてみよう # 2つの数字を入力し、足し算と引き算の結果を出力してください。\n1つ目の数字: 4 2つ目の数字: 2 足し算の合計 6 引き算の合計 2 input() で受け取った文字列を int() で整数に変換し、+ と - の演算子を使って計算します。\n回答 x = int(input(\u0026#34;1つ目の数字: \u0026#34;)) y = int(input(\u0026#34;2つ目の数字: \u0026#34;)) print(\u0026#34;足し算の合計\u0026#34;, x + y) print(\u0026#34;引き算の合計\u0026#34;, x - y) 九九の表を作ろう # 九九を「式と答え」をセットで表示してください。\n1 x 1 = 1 1 x 2 = 2 ... 9 x 9 = 81 二重の for ループを使い、print() 関数で式と答えを整形して出力します。\n回答 for i in range(1, 10): for j in range(1, 10): print(i, \u0026#34;x\u0026#34;, j, \u0026#34;=\u0026#34;, i * j) 正方形を描こう # 入力された大きさの正方形を「*」で描きましょう。\n# 5の場合 ***** * * * * * * ***** for ループの中で if 文を使い、最初の行と最後の行、それ以外の行で処理を分けることで、中が空洞の図形を描くことができます。\n回答 h = int(input(\u0026#34;数字を入力してください: \u0026#34;)) for i in range(h): if i == 0 or i == h - 1: print(\u0026#34;*\u0026#34; * h) else: print(\u0026#34;*\u0026#34; + \u0026#34; \u0026#34; * (h - 2) + \u0026#34;*\u0026#34;) フィボナッチ数列を出力しよう # 10000未満のフィボナッチ数列を出力してください。\n0 1 1 2 3 5 8 ... 6765 フィボナッチ数列は、前の2つの項の和が次の項になる数列です。a, b = b, a + b のように値を更新していくことで、数列を生成できます。\n回答 a, b = 0, 1 while a \u0026lt; 10000: print(a, end=\u0026#34; \u0026#34;) a, b = b, a + b print() 2つの素数判定 # ユーザーから入力した2つの数字が両方とも素数なら True、そうでなければ False と出力してください。\n1つ目の数字を入力してください: 7 2つ目の数字を入力してください: 11 True 素数判定のロジックを is_prime という関数にまとめることで、同じ処理を何度も書く必要がなくなり、コードが読みやすくなります。\n回答 def is_prime(n): if n \u0026lt;= 1: return False for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return False return True num1 = int(input(\u0026#34;1つ目の数字を入力してください: \u0026#34;)) num2 = int(input(\u0026#34;2つ目の数字を入力してください: \u0026#34;)) print(is_prime(num1) and is_prime(num2)) バブルソートに挑戦！ # 整数リストを引数に取り、バブルソートで昇順に並べ替える関数を作りましょう。\n関数にリストを渡して、ソート前とソート後を表示してください。\n[5, 3, 8, 1, 9] =\u0026gt; [1, 3, 5, 8, 9] バブルソートは、隣り合う要素を比較して入れ替えながら、リスト全体を整列させるアルゴリズムです。\n回答 def bubble_sort(data): for i in range(len(data) - 1): for j in range(len(data) - i - 1): if data[j] \u0026gt; data[j + 1]: data[j], data[j + 1] = data[j + 1], data[j] return data data = [5, 3, 8, 1, 9] print(f\u0026#34;{data} =\u0026gt; {bubble_sort(data.copy())}\u0026#34;) ","date":"2025年 9月 7日","externalUrl":null,"permalink":"/scraps/python-practice2/","section":"Scraps","summary":"","title":"Python基礎レベルハンズオン","type":"scraps"},{"content":"このページは、Pythonの基本的な文法を学ぶためのハンズオン形式の練習問題集です。各問題には、解答例としてPythonコードが記載されています。\n文字の連結 # + 演算子を使用して、文字列同士を連結することができます。\n名前と挨拶を結合して「Hello, Taro!」と出力してください name = \u0026#34;Taro\u0026#34; greeting = \u0026#34;Hello, \u0026#34; + name + \u0026#34;!\u0026#34; print(greeting) 変数 # 変数に値を代入し、その変数を使って計算を行うことができます。\nりんごの数が3個、みかんの数が5個あるとき、合計を変数に代入して表示してください。 apples = 3 oranges = 5 total = apples + oranges print(total) print() 関数 # print() 関数は、括弧内の値や文字列を画面に出力します。\n「Pythonを学習中」と表示してください。 print(\u0026#34;Pythonを学習中\u0026#34;) input() 関数 # input() 関数は、ユーザーからのキーボード入力を受け取り、その値を返します。\n名前を入力すると「こんにちは ○○ さん」と表示するプログラムを作ってください。 name = input(\u0026#34;あなたの名前は？: \u0026#34;) print(\u0026#34;こんにちは \u0026#34; + name + \u0026#34; さん\u0026#34;) 論理演算子 # and や or などの論理演算子を使って、複数の条件を組み合わせることができます。\n年齢を入力し、20歳以上かつ30歳未満なら「20代です」と表示、それ以外は「20代ではありません」と表示してください。 age = int(input(\u0026#34;年齢を入力してください: \u0026#34;)) if age \u0026gt;= 20 and age \u0026lt; 30: print(\u0026#34;20代です\u0026#34;) else: print(\u0026#34;20代ではありません\u0026#34;) if文 # if 文を使うと、条件が真の場合に特定の処理を実行できます。else を使うと、条件が偽の場合の処理も記述できます。\n点数を入力し、60点以上なら「合格」、それ未満なら「不合格」と表示してください。 score = int(input(\u0026#34;点数を入力してください: \u0026#34;)) if score \u0026gt;= 60: print(\u0026#34;合格\u0026#34;) else: print(\u0026#34;不合格\u0026#34;) 配列（リスト） # リスト（配列）は、複数の値をまとめて格納できるデータ型です。sum() で合計、len() で要素数を取得できます。\n配列の「10, 20, 30, 40」平均値を計算して表示してください。 numbers = [10, 20, 30, 40] average = sum(numbers) / len(numbers) print(\u0026#34;平均:\u0026#34;, average) 繰り返し（for） # for ループは、指定した回数だけ処理を繰り返します。range() 関数と組み合わせて使うことが多いです。\n1から5までの数をすべて出力してください。 for i in range(1, 6): print(i) 繰り返し（while） # while ループは、指定した条件が真である間、処理を繰り返します。\n入力された数が0になるまで、その数を表示し続けるプログラムを作ってください。 num = int(input(\u0026#34;数を入力してください(0で終了): \u0026#34;)) while num != 0: print(\u0026#34;入力された数:\u0026#34;, num) num = int(input(\u0026#34;数を入力してください(0で終了): \u0026#34;)) ","date":"2025年 9月 7日","externalUrl":null,"permalink":"/scraps/python-practice/","section":"Scraps","summary":"","title":"Python入門レベルハンズオン","type":"scraps"},{"content":" requirements.txtとは # requirements.txtはPythonプロジェクトで使用しているパッケージ名とバージョンを記述したテキストファイルです。 「requirements」は英語で「要件」や「必要条件」を意味します。\nrequirements.txtの書き方 # # パッケージ名のみ記述すると、その時点での最新版がインストールされます requests numpy pandas # バージョンを指定する場合は「==」で完全一致、「\u0026gt;=」「\u0026lt;」などで範囲を指定します Flask==3.0.3 SQLAlchemy\u0026gt;=2.0.0,\u0026lt;3.0.0 requirements.txtを実行するコマンド # # 既存の環境からrequirements.txtを作成する場合、pipのfreezeコマンドを使用 pip freeze \u0026gt; requirements.txt # requirements.txtからパッケージをインストール pip install -r requirements.txt 参考リンク # エンべーダー：requirements.txtの使い方 ","date":"2025年 9月 7日","externalUrl":null,"permalink":"/scraps/study-requirements/","section":"Scraps","summary":"","title":"勉強メモ：requirements.txt","type":"scraps"},{"content":" virtualenvとは？ # virtualenvは、Pythonで複数の仮想環境を作成・管理できるツールです。これにより、異なるアプリやプロジェクトごとにパッケージ・バージョンの設定を分離できます\nPythonにおける仮想環境とは？ # 仮想環境とは、一時的・独立したPythonの実行環境です。これを使うことで、システムのPython設定に影響を与えず、個別にパッケージ導入や、Pythonバージョンの切替ができます。\nvenvとvirtualenvの違い # venvはPython3.3以降で標準搭載されている機能ですが、Python本体のバージョン管理はできません。\nvirtualenvは、仮想環境ごとに異なるPythonバージョンを指定して管理可能です。これにより、特定の旧バージョンPythonでの動作検証など柔軟に対応できます。\nvirtualenvのinstall # # virtualenvは標準ではインストールされていないため、pipで導入が必要 sudo pip install virtualenv virtualenvコマンドで新しい環境の作成 # # プロジェクト用ディレクトリを準備 mkdir プロジェクトディレクトリ名 cd プロジェクトディレクトリ名 # 通常の仮想環境作成 python3 -m virtualenv 仮想環境名 # 特定バージョンのPythonを指定する場合（要事前インストール） python3 -m virtualenv -p 利用したいPythonのバージョン(例: python3.6) 環境名 仮想環境の起動(activate)・停止(deactivate) # # 仮想環境を有効化 source 仮想環境名/bin/activate # コマンドライン先頭に(仮想環境名)が表示されたら正常起動 # 仮想環境を終了 deactivate # (仮想環境名)表示が消えたら仮想環境解除 参考リンク # エンべーダー：venvの使い方\n","date":"2025年 9月 7日","externalUrl":null,"permalink":"/scraps/study-virtualenv/","section":"Scraps","summary":"","title":"勉強メモ：virtualenv","type":"scraps"},{"content":"","date":"2025年 9月 7日","externalUrl":null,"permalink":"/tags/%E8%AA%AD%E6%9B%B8%E3%83%A1%E3%83%A2/","section":"Tags","summary":"","title":"読書メモ","type":"tags"},{"content":" 書籍情報 # 項目 説明 書籍名 「指示通り」ができない人たち 著者 榎本博明 発行年 2024/03/08 発行者 株式会社日経BP 購入の経緯 # 日々の業務における自身の課題を省みた際、ソフトスキル、特に非認知能力の低さを改善する必要があると感じていました。本書がそのヒントになると考え、購入に至りました。\n本書の要点と構成 # 本書は、「指示通り」に業務を遂行できない人々を以下の3つのタイプに分類し、それぞれのケースと原因、改善策を解説しています。\n認知能力に課題がある人 メタ認知能力に課題がある人 非認知能力に課題がある人 改善策の柱として、**「読書」や「文章の要約」を通じて読解力を鍛えることが提言されています。また、関連書籍としてダニエル・ゴールドマンの『EQ こころの知能指数』**も紹介されており、感情的知性の重要性にも触れられています。\nこのメモでは、本書の中から特に自身が共感した、あるいは興味を引かれたケースを抽出し、その内容と改善策をまとめ、今後の自身の行動計画へと繋げます。\n特に印象に残ったケースと考察 # 1. 認知能力：「パニックに弱い人」 # 複数のタスクを同時に振られると混乱してしまうケースです。本書では、これはワーキングメモリの容量が少ないことが一因であると解説されています。 【改善策】 タスクの優先順位を都度明確にし、一つの作業に集中する環境を意識的に作ることが有効です。\n2. メタ認知能力：「同じミスを繰り返す人」 # 過去の指摘を忘れてしまい、同様の失敗を繰り返すケースです。これは、単なる記憶力の問題だけでなく、自身の行動を客観視できていないことに起因します。 【改善策】 指摘されたことをその場でメモに取る、一日の終わりに日記などで自身の行動を振り返るなど、内省を習慣化することが重要です。\n3. 非認知能力：「能力は高いが、対人関係が苦手な人」 # 業務遂行能力や知識は豊富であるにもかかわらず、顧客との交渉など対人関係に強い不安を感じ、キャリアの機会を逃してしまうケースです。 【改善策】 本書では、この「対人不安」は多くの人が抱える普遍的な感情であると指摘しています。まずはその事実を受け入れ、小さな成功体験を積むことで、徐々に不安を克服していくことが推奨されています。\nまとめと今後の行動 # 本書で紹介されている様々なケースの根底には、「読解力」「内省する力」「他者と関わる力（EQ）」の不足があると感じました。そして、これらの能力は、日々の意識とトレーニングによって改善可能であると述べられています。\n具体的なトレーニング方法として、\n読書と要約: 平易な文章からで良いので、内容を要約する習慣をつけることで読解力を養う。 日々の内省: 日記やメモを活用し、自身の行動や感情を客観的に振り返る。 コミュニケーション: 他者との対話を通じて、感情的知性（EQ）を高める。 といったアプローチが紹介されていました。\nこれらの提言を踏まえ、私自身もまずは**「読書メモの作成」と「日記による日々の振り返り」**を継続的に実践し、自身の課題改善に繋げていこうと考えています。\n","date":"2025年 9月 7日","externalUrl":null,"permalink":"/scraps/memo-sijidourigadekinai/","section":"Scraps","summary":"","title":"読書メモ 「指示通り」ができない人たち","type":"scraps"},{"content":" pipとは何か？ # pipはPythonの公式パッケージ管理ツールで、Pythonコミュニティで広く採用されています。 Pythonの標準ライブラリに含まれているか、Python 3.4以降は ensurepip によって容易にインストールできるようになりました。 目的は、Pythonの外部モジュールやライブラリ（パッケージ）を簡単に導入し、依存関係も自動管理することです。 パッケージと依存関係の理解 # パッケージとは：\nPythonのコード・データを1つにまとめ配布できる単位。機能ごとに分かれている。 例：Web開発用のFlask、HTTP通信を助けるrequestsなど。 依存関係とは：\nあるパッケージが動作するために必要な、他のパッケージのこと。 例えばFlaskはWerkzeugやJinja2など使っているため、それらが事前にインストールされている必要がある。 pipは依存関係も自動的に解決し、必要なパッケージを連鎖的にインストールしてくれる。 仮想環境（venv）を使う理由 # システム全体に影響を与えず、プロジェクト単位でパッケージを管理できる。 依存関係の衝突を避け、異なるプロジェクトで別バージョンのパッケージを共存可能にする。 開発・テスト用のクリーンな環境を手軽に作られる。 mkdir my_project # プロジェクトディレクトリ作成 cd my_project python3 -m venv venv # 仮想環境作成 source venv/bin/activate # 仮想環境有効化 (Linux/macOS) # Windowsの場合 # venv\\Scripts\\activate.bat # cmd # または # venv\\Scripts\\Activate.ps1 # PowerShell pipの基本操作 # バージョン確認・インストール確認 # pip -V # pipのバージョンとPython環境を確認 もしpipがない場合や更新したい場合は、以下：\npython3 -m ensurepip --default-pip # pipをインストール pip install --upgrade pip # pipのアップグレード パッケージのインストール # pip install Flask # 最新版をインストール pip install Flask==2.3.3 # バージョン指定してインストール pip install \u0026#34;Flask\u0026gt;=2.2,\u0026lt;3.0\u0026#34; # 範囲指定インストール パッケージのアンインストール # pip uninstall Flask # パッケージ削除 インストール済みパッケージの確認 # ライブラリ一覧を見たい時は以下コマンドを使う。 pip list # パッケージとバージョンの一覧 pip freeze # requirements.txt形式でパッケージ＋バージョンを表示 pip freeze は環境の再現性を確保するのに役立つ。 パッケージの詳細情報 # pip show Flask # 表示される例: # Name: Flask # Version: 2.3.3 # Summary: A simple framework for building complex web applications. # Home-page: https://palletsprojects.com/p/flask/ # Author: Armin Ronacher # Author-email: armin.ronacher@active-4.com # License: BSD-3-Clause # Location: /path/to/venv/lib/python3.12/site-packages # Requires: Werkzeug, Jinja2 # Required-by: requirements.txt の利用 # 複数パッケージをまとめて管理・共有できるテキストファイル。 チーム開発やCI/CD環境での環境再現に必須。 # 現在の環境のパッケージをファイル化 pip freeze \u0026gt; requirements.txt # ファイルから環境を再現 pip install -r requirements.txt ベストプラクティス・注意点 # 仮想環境を必ず使う\nシステム環境に影響を与えず複数プロジェクトを管理できる\nバージョン固定を行い再現性を担保\nrequirements.txtやpip freezeを活用し、同じバージョンセットを共有・再利用する\nC拡張モジュールの依存に注意\nMySQLクライアントや画像処理ライブラリなどは、Python依存に加えシステム側にもライブラリが必要な場合がある。\npip のアップグレードを定期的に\nセキュリティやバグ修正、新機能のために最新版を利用する\nまとめ コマンド一覧（代表例） # コマンド 説明 pip install \u0026lt;pkg\u0026gt; パッケージを最新バージョンでインストール pip install \u0026lt;pkg\u0026gt;==\u0026lt;version\u0026gt; 指定バージョンでインストール pip uninstall \u0026lt;pkg\u0026gt; パッケージをアンインストール pip list インストール済みパッケージの一覧表示 pip freeze 環境再現用のrequirements.txt形式で一覧出力 pip show \u0026lt;pkg\u0026gt; パッケージの詳細情報（依存・場所など） pip install -r requirements.txt requirements.txtファイルに基づいて一括インストール pip install --upgrade pip pip自身のアップデート ","date":"2025年 9月 6日","externalUrl":null,"permalink":"/scraps/study-pip/","section":"Scraps","summary":"","title":"勉強メモ：pipコマンド","type":"scraps"},{"content":" はじめに # venvは、Python 3.3から標準ライブラリに加わった、仮想環境を管理するためのツールです。\nPythonで開発を行う際、プロジェクトごとに利用するパッケージのバージョンが異なることは珍しくありません。venvを使うと、プロジェクトごとに独立したPython環境を構築できます。これにより、他のプロジェクトやシステム全体に影響を与えることなく、パッケージのインストールやバージョン管理を安全に行うことができます。\nvenvの基本的な使い方 # 仮想環境を利用する基本的な流れは、「作成 → 有効化 → パッケージインストール → 無効化」となります。\n1. 仮想環境の作成 # まず、プロジェクト用のディレクトリを作成し、その中で仮想環境を構築します。\n# プロジェクトディレクトリを作成して移動 mkdir my_project cd my_project # 仮想環境を作成（慣習的に`venv`という名前が使われます） python3 -m venv venv 作成が完了すると、venvという名前のディレクトリができます。このディレクトリは、Gitなどのバージョン管理システムから除外するために、.gitignoreファイルにvenv/と追記しておくのが一般的です。\n2. 仮想環境の有効化（activate） # 作成した仮想環境は、有効化（activate）することで利用可能になります。コマンドはOSによって異なります。\nmacOS/Linux:\nsource venv/bin/activate Windows (コマンドプロンプト):\nvenv\\Scripts\\activate コマンドが成功すると、ターミナルのプロンプトの先頭に(venv)のように仮想環境名が表示されます。\n3. パッケージのインストール # 仮想環境が有効な状態でpipコマンドを使うと、その環境内にのみパッケージがインストールされます。\n# 例としてrequestsパッケージをインストール pip install requests # インストールされたパッケージを確認 pip list プロジェクトで利用するパッケージは、requirements.txtというファイルにまとめておくと便利です。\n# 現在の環境にインストールされているパッケージをファイルに出力 pip freeze \u0026gt; requirements.txt # requirements.txtからパッケージをまとめてインストール pip install -r requirements.txt 4. 仮想環境の無効化（deactivate） # 仮想環境での作業が終わったら、以下のコマンドで無効化（deactivate）します。\ndeactivate プロンプトの(venv)という表示が消え、元のターミナル環境に戻ります。\nvenvとvirtualenvの違い # venvが登場する前は、virtualenvというサードパーティ製のツールが広く使われていました。主な違いは以下の通りです。\nvenv: Python 3.3以降の標準機能。追加インストールは不要。 virtualenv: 別途インストールが必要 (pip install virtualenv)。venvよりも高機能な面もあるが、基本的な用途ではvenvで十分。 特別な理由がなければ、標準ライブラリであるvenvの使用が推奨されます。\n補足：Python自体のバージョンを管理したい場合 # venvはPythonのパッケージ環境を分離しますが、Python自体のバージョン（例: 3.9と3.10）を切り替えることはできません。複数のPythonバージョンを管理したい場合は、pyenvのような専用ツールの利用を検討してください。\n参考資料 # Python公式ドキュメント: venv — 仮想環境の作成 ","date":"2025年 9月 6日","externalUrl":null,"permalink":"/scraps/study-venv/","section":"Scraps","summary":"","title":"勉強メモ：venv","type":"scraps"},{"content":"","date":"2025年 9月 6日","externalUrl":null,"permalink":"/tags/blowfish/","section":"Tags","summary":"","title":"Blowfish","type":"tags"},{"content":"","date":"2025年 9月 6日","externalUrl":null,"permalink":"/tags/github-pages/","section":"Tags","summary":"","title":"Github Pages","type":"tags"},{"content":"","date":"2025年 9月 6日","externalUrl":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo","type":"tags"},{"content":" はじめに # HugoとBlowfishテーマで作成し、GitHub Pagesで公開しているブログサイトを、Googleの検索結果に表示させるための設定手順を解説します。\n手順の概要は以下の通りです。\nHugo/Blowfishの設定: 検索エンジンにサイトのクロールを許可します。 Google Search Consoleでの設定: Googleにサイトを認識させ、所有権の確認とサイトマップの送信を行います。 ステップ1：robots.txtの有効化 # まず、検索エンジンがサイトをクロールできるように、Hugoの設定ファイルでrobots.txtの生成を有効にします。\nconfig/_default/hugo.toml\n# trueに設定すると、検索エンジンがサイト全体をクロールすることを許可するrobots.txtが生成されます。 enableRobotsTXT = true ステップ2：Google Search Consoleへの登録と設定 # 次に、Google Search Consoleを利用してサイトをGoogleに登録します。\n1. Google Search Consoleへアクセス # Google Search Consoleにアクセスし、利用を開始します。\n2. プロパティの追加 # プロパティタイプを選択します。今回は「URLプレフィックス」を選択し、ご自身のサイトURL（例: https://example.com/）を入力します。\n3. 所有権の確認 # サイトの所有者であることを確認します。複数の方法がありますが、ここでは「HTMLタグ」方式を選択します。表示されたメタタグをコピーしてください。\n4. メタタグをサイトに追加 # コピーしたメタタグをサイトの\u0026lt;head\u0026gt;セクションに追加します。Blowfishテーマでは、layouts/partials/extend-head.htmlというファイルを作成または編集し、以下の内容を追記することで簡単に追加できます。\nlayouts/partials/extend-head.html\n\u0026lt;!-- Google Search Consoleの所有権確認用メタタグ --\u0026gt; \u0026lt;meta name=\u0026#34;google-site-verification\u0026#34; content=\u0026#34;コピーした文字列\u0026#34; /\u0026gt; このファイルを配置することで、サイトの全ページの\u0026lt;head\u0026gt;内に指定したタグが挿入されます。\n5. 所有権の確認を実行 # サイトをデプロイした後、Google Search Consoleの画面に戻り、「確認」ボタンをクリックします。無事に所有権が確認されれば、設定は完了です。\n6.Google Search Consoleにてインデックスへ登録申請 # 左側のメニューより「URL検査」を選択 自分のサイトのURLを入力して検索。検索後に表示される「インデックス登録をリクエスト」を選択\n正常完了すると上記が表示される。\nまとめ：検索結果に表示されるまで # 上記の手順が完了すると、Googleのクローラーがあなたのサイトを巡回し、内容をインデックスに登録するようになります。\nインデックス登録のリクエスト: 新しい記事を公開した際など、早くインデックスさせたい場合は、Search Consoleの「URL検査」ツールから個別にリクエストを送信できます。 反映までの時間: サイトが検索結果に表示されるまでには、数日から数週間かかる場合があります。インデックス状況はSearch Consoleで確認できます。 これで、サイトがGoogle検索に表示されるための基本的な設定は完了。\n参考記事 # Blowfish：サイト設定 エンベーター：Googleサーチコンソールとは？基本的な使い方や導入方法を解説 ","date":"2025年 9月 6日","externalUrl":null,"permalink":"/posts/how-to-get-your-hugo+blowfish-website-indexed-by-google/","section":"Posts","summary":"","title":"Hugo+Blowfishで構築したサイトをGoogle検索に表示させる手順","type":"posts"},{"content":"","date":"2025年 9月 6日","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2025年 9月 6日","externalUrl":null,"permalink":"/tags/seo/","section":"Tags","summary":"","title":"SEO","type":"tags"},{"content":" pyenvとは？ # pyenvは、Pythonの複数のバージョンを簡単に切り替えて管理するためのツールです。プロジェクトごとに異なるPythonバージョンを利用したい場合などに役立ちます。\nインストール手順 (Ubuntu) # 1. 依存関係のインストール # Pythonのビルドに必要なパッケージをあらかじめインストールします。\nsudo apt update sudo apt install build-essential libffi-dev libssl-dev zlib1g-dev liblzma-dev libbz2-dev libreadline-dev libsqlite3-dev tk-dev git ※参考記事：Ubuntuにpyenvをインストール\n2. pyenvのインストール # GitHubからpyenvのリポジトリをクローンします。\ngit clone https://github.com/pyenv/pyenv.git ~/.pyenv 3. 環境変数の設定（パスを通す） # ~/.bashrc（Zshの場合は ~/.zshrc）に以下の3行を追記します。\necho \u0026#39;export PYENV_ROOT=\u0026#34;$HOME/.pyenv\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#39;command -v pyenv \u0026gt;/dev/null || export PATH=\u0026#34;$PYENV_ROOT/bin:$PATH\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#39;eval \u0026#34;$(pyenv init -)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc 設定を反映させるため、ターミナルを再起動するか、source ~/.bashrc を実行します。\n基本的な使い方 # Pythonのインストール # # インストール可能なバージョンの一覧を表示 pyenv install --list # 指定したバージョンをインストール pyenv install 3.10.4 使用するPythonのバージョンを切り替える # pyenvでは、global と local の2つの方法でバージョンを指定できます。\nglobal: システム全体でデフォルトとして使用するバージョンを設定します。 local: 現在のディレクトリ（プロジェクト）でのみ有効なバージョンを設定します。 # インストール済みのバージョン一覧を確認 pyenv versions # 全体で使うバージョンを設定 pyenv global 3.10.4 # 現在のディレクトリで使うバージョンを設定（.python-versionファイルが作成される） pyenv local 3.9.13 Pythonのアンインストール # pyenv uninstall 3.10.4 pyenvのアップデート # 方法1: pyenv-updateプラグインを使う # pyenv-updateというプラグインを導入すると、pyenv updateコマンドで簡単に更新できます。\n# 1. プラグインをインストール（初回のみ） git clone https://github.com/pyenv/pyenv-update.git $(pyenv root)/plugins/pyenv-update # 2. pyenvをアップデート pyenv update 方法2: gitで直接アップデートする # pyenv本体はgitリポジトリなので、git pullで直接更新することも可能です。\ncd $(pyenv root) git pull インストール時のトラブルシューティング # pyenv install 時にエラーが出た場合の対処法です。多くは依存パッケージ不足が原因です。\nconfigure: error: no acceptable C compiler found in $PATH # Cコンパイラが見つからないエラーです。build-essentialをインストールします。\nsudo apt install build-essential zipimport.ZipImportError: can't decompress data; zlib not available # zlibライブラリがないエラーです。zlib1g-devをインストールします。\nsudo apt install zlib1g-dev ","date":"2025年 9月 4日","externalUrl":null,"permalink":"/scraps/study-pyenv/","section":"Scraps","summary":"","title":"勉強メモ：pyenv","type":"scraps"},{"content":" はじめに # python用の勉強メモをスクラップとしてまとめます。\nPythonとは # Pythonは1991年に開発された、シンプルで読みやすい文法が特徴のプログラミング言語です。\nインデント（字下げ）でコードのブロックを表現することが大きな特徴です。 文法が比較的シンプルなため、プログラミング初心者でも学習しやすい言語と言われています。 近年では、AI開発や機械学習、データ分析などの分野で特に広く活用されています。 Pythonのインストール方法（Linux/Debian系） # Linux（DebianやUbuntuなど）環境でPython3をインストールする手順です。\nsudo apt update sudo apt install -y python3 コマンドの解説\nsudo apt update: インストール可能なパッケージのリストを最新の状態に更新します。 sudo apt install -y python3: Python3をインストールします。 -yオプションは、インストール中の確認メッセージに対して自動的に「Yes」と回答するためのものです。 インストール後の確認 # インストールが正常に完了したかを確認するには、ターミナルで以下のコマンドを実行します。\npython3 --version 次のように、インストールされたPythonのバージョンが表示されれば成功です。\nPython 3.x.x ※ x.xの部分には、インストールされたバージョン番号が表示されます。\nPythonの対話モード # Pythonのプログラムを実行するには、主に2つの方法があります。\n対話モード: ターミナルで直接コードを一行ずつ入力して実行する方法。 スクリプト実行: .pyファイルにコードを記述し、そのファイルを一括で実行する方法。 対話モードは、ターミナルでpython3コマンドを実行すると開始できます。コードを試したり、簡単な計算をしたりするのに便利です。\n$ python3 Python 3.x.x (default, ... Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;Hello, Python!\u0026#34;) Hello, Python! \u0026gt;\u0026gt;\u0026gt; 対話モードを終了するには、exit()と入力するか、Ctrl + Dを押します。\n関数 (Functions) # 関数は、特定の処理をひとまとめにしたものです。同じ処理を何度も書きたいときに便利です。\ndef 関数名(引数): # ここに処理を書く return 戻り 引数 (argument): 関数に渡す値。 戻り値 (return value): 関数の処理結果として返される値。 例：あいさつする関数 # def greet(name): \u0026#34;\u0026#34;\u0026#34;名前を受け取って、あいさつのメッセージを返す関数\u0026#34;\u0026#34;\u0026#34; message = f\u0026#34;こんにちは、{name}さん！\u0026#34; return message # 関数を呼び出して、戻り値を変数に受け取る greeting = greet(\u0026#34;山田\u0026#34;) print(greeting) # 出力: こんにちは、山田さん！ 練習問題 # 2つの数値を受け取り、その積（掛け算の結果）を返す multiply という名前の関数を作成してください。 その後、その関数を使って 5 と 8 の積を計算し、結果をコンソールに出力してください。\n解答例 # 2つの数値の積を返す関数 def multiply(num1, num2): return num1 * num2 # 関数を呼び出して結果を計算 result = multiply(5, 8) print(f\u0026#34;5と8の積は {result} です。\u0026#34;) # 出力: 5と8の積は 40 です。 クラス (Classes) # クラスは、オブジェクトの「設計図」です。データ（属性）と処理（メソッド）を一つにまとめることができます。\nclass クラス名: # コンストラクタ (初期化メソッド) def __init__(self, 引数): self.インスタンス変数 = 引数 # メソッド def メソッド名(self): # 処理 return self.インスタンス変数 インスタンス: クラス（設計図）から作られた実体のこと。 __init__: インスタンスが作られるときに最初に呼ばれる特別なメソッド。 self: インスタンス自身を指す特別な変数。 例：人物を表すクラス # class Person: def __init__(self, name, age): self.name = name # 属性 (インスタンス変数) self.age = age def introduce(self): # メソッド return f\u0026#34;私の名前は{self.name}、{self.age}歳です。\u0026#34; # Personクラスから「インスタンス」を作成 person1 = Person(\u0026#34;鈴木\u0026#34;, 25) # 属性やメソッドを使う print(person1.name) print(person1.introduce()) # 出力: # 鈴木 # 私の名前は鈴木、25歳です。 練習問題 # Dog というクラスを作成してください。\n__init__ メソッドで犬の名前(name)を受け取り、インスタンス変数に設定してください。 bark というメソッドを定義し、呼び出されると「(名前)はワン！と鳴いた」という文字列を返すようにしてください。 その後、Dog クラスから \u0026ldquo;ポチ\u0026rdquo; という名前のインスタンスを作成し、bark メソッドを呼び出して結果を出力してください。\n解答例 class Dog: def __init__(self, name): self.name = name def bark(self): return f\u0026#34;{self.name}はワン！と鳴いた\u0026#34; # インスタンスを作成 my_dog = Dog(\u0026#34;ポチ\u0026#34;) # メソッドを呼び出し message = my_dog.bark() print(message) # 出力: ポチはワン！と鳴いた モジュールとインポート (Modules \u0026amp; Import) # モジュールは、関数やクラスをまとめたPythonファイル（.pyファイル）のことです。他のファイルから再利用できます。\nモジュールの作成 # 例えば、utils.py という名前で以下のファイルを作成したとします。\nPI = 3.14159 def circle_area(radius): \u0026#34;\u0026#34;\u0026#34;円の面積を計算する\u0026#34;\u0026#34;\u0026#34; return PI * (radius ** 2) モジュールの利用 (インポート) # 同じディレクトリにある別のファイル (main.pyなど) から、utils.py の中身をインポートして使えます。\nimport utils # utilsモジュールの中の変数や関数を使う radius = 5 area = utils.circle_area(radius) print(f\u0026#34;半径{radius}の円の面積は {area} です。\u0026#34;) print(f\u0026#34;円周率は {utils.PI} です。\u0026#34;) 練習問題 # string_utils.py というモジュールがあると仮定します。このモジュールには、文字列を逆にする reverse という関数が定義されています。\ndef reverse(text): return text[::-1] from ... import ... 構文を使って string_utils モジュールから reverse 関数だけをインポートし、\u0026quot;hello\u0026quot; という文字列を逆にして出力してください。\n解答例 # string_utils から reverse 関数だけをインポート from string_utils import reverse # インポートした関数を直接使える reversed_text = reverse(\u0026#34;hello\u0026#34;) print(reversed_text) # 出力: olleh 関連ライブラリ・ツール # Python関連のスクラップへリンクを下記にまとめます。\nNumpy # Pythonで科学技術計算を効率的に行うためのコアライブラリ スクラップメモはこちら\npyenv # Pythonのバージョン管理を簡単にするツール スクラップメモはこちら\nvenv # 仮想環境を管理するためのツール スクラップメモはこちら\nvirtualenv # 仮想環境を管理するためのツール（venvと類似している） スクラップメモはこちら\npipコマンド # pipはPythonの公式パッケージ管理ツール スクラップメモはこちら\nrequirements.txt # Pythonプロジェクトで使用しているパッケージ名とバージョンを記述したテキストファイル スクラップメモはこちら\npandas # データを扱う際によく用いられるライブラリ スクラップメモはこちら\n練習問題 # 入門レベルのハンズオン 基礎レベルのハンズオン 参考リンク # ゼロからのPython入門講座 Python チュートリアル ","date":"2025年 9月 3日","externalUrl":null,"permalink":"/scraps/styudy-python/","section":"Scraps","summary":"","title":"勉強メモ：Python","type":"scraps"},{"content":" スクラップメモの目的 # 応用情報技術者試験勉強中の知らないキーワードや概念をメモにして整理 参考資料 # 令和07年【春期】【⁠秋期】応用情報技術者 合格教本 応用情報技術者過去問道場 ユーザービリティ評価手法 # アンケート # 質問票を配布してユーザーから回答を集める手法。\n思考発話法 # 被験者に操作をしながら考えていることを声に出してもらい、思考プロセスを分析する手法。\n回顧法 # 操作後に操作内容やその時の判断、感想などを思い出してもらい、ヒアリングする手法。\nログデータ分析法 # ユーザーの操作ログを収集・解析し、利用状況や問題点を定量的に評価する手法。\n認知的ウォークスルー法 # 専門家がユーザーの視点に立ってタスクを実行し、ユーザーが目標を達成できるか、操作で迷わないかなどを評価する手法。\nヒューリスティック評価 # 専門家が経験則（ヒューリスティックス）に基づいて、UIなどがガイドラインに沿っているかを評価する手法。\n二モニックコード # 商品の略称や記号など、記憶しやすいように意味を持たせたコード。 例：「B5」→ B5用紙 別名：表意コード\nパンくずリスト # Webサイト内でユーザーが現在閲覧しているページの位置を、トップページからの階層構造で示したもの。 名前の由来は童話「ヘンゼルとグレーテル」で、主人公が森で迷わないようにパンくずを落として道しるべにした逸話から。\nコンピュータグラフィックスの基本技術 # レンダリング # 3D空間の物体のデータ（形状、質感、光源など）を基に、2次元の画像を生成する処理。\nレイトレーシング法 # 光源から出た光が物体に反射し、視点に届くまでの経路を逆に追跡することで、リアルな画像を生成するレンダリング手法。光の反射や屈折を精密に計算できる。\nZバッファ法 # 視点からの奥行き情報（Z値）をピクセルごとに保持し、不要な部分（隠れた部分）を描画しないことで、効率的に隠面消去を行うレンダリング手法。\nラジオシティ法 # 物体表面での光の相互反射（間接光）を計算することで、柔らかな陰影や、部屋の壁が照らし合う様子などをリアルに表現するレンダリング手法。\nアンチエイリアシング # 斜線や曲線の境界に生じる階段状のギザギザ（ジャギー）を、中間色を補うことで滑らかに見せる手法。\nディザリング # 色数が限られた環境で、異なる色のピクセルを隣接して配置することで、擬似的に中間色や多くの色を表現する手法。\nメタボール # 複数の球体を定義し、それらが融合し合うような滑らかで有機的な曲面を生成するモデリング手法。液体や粘体などの表現に用いられる。\nパルス符号変調（PCM）の符号化手順 # 標本化（サンプリング） アナログ信号を一定の時間間隔で区切り、その瞬間の値を取り出す。1秒間にサンプリングする回数をサンプリング周波数（Hz）と呼ぶ。\n量子化 標本化で得られたアナログ値を、最も近い離散的な値（整数値）に近似する。このとき、1つの値を表現するために使うビット数を量子化ビット数と呼ぶ。\n符号化 量子化で得られた整数値を、0と1の2進符号に変換する。\n全般統制と業務処理統制の違い # 全般統制：組織や集団全体を対象 業務処理統制：個々の業務が対象 システム監査基準 # 監査人が従うべき行動規範\n計算問題 # 帯域幅（R6秋午前問26） # 問題\n解像度: 800 × 600 ピクセル 色深度: 24ビットフルカラー フレームレート: 30フレーム/秒 上記の動画像の配信に最低限必要な帯域幅はいくつか。\n計算\n1フレームあたりのデータ量 800 × 600 ピクセル × 24 ビット/ピクセル = 11,520,000 ビット = 11.52 Mビット\n1秒あたりのデータ量（帯域幅） 11.52 Mビット/フレーム × 30 フレーム/秒 = 345.6 Mビット/秒 (Mbps)\n答え 345.6 Mbps\n色数（H17春午前問22） # 問題 あるディスプレイのビデオメモリは、解像度「800 × 600画素」で最大「2^16色」の表示が可能である。このビデオメモリを流用して解像度を「1600 × 1200画素」に変更した場合、表示できる最大の色数はいくつか。\n計算\n必要なビデオメモリ容量の計算\n1画素あたりのデータ量: 2^16色を表現するには16ビット（= 2バイト）必要。 ビデオメモリ容量: 800 × 600 画素 × 2 バイト/画素 = 960,000 バイト 変更後の解像度で1画素あたりに割り当てられるデータ量の計算\n変更後の総画素数: 1600 × 1200 画素 = 1,920,000 画素 1画素あたりのデータ量: 960,000 バイト / 1,920,000 画素 = 0.5 バイト = 4 ビット 最大色数の計算 4ビットで表現できる色数は 2^4 色。\n答え 2^4色\n音声サンプリング（H18春午前問55） # 問題\nサンプリング周波数: 11,000回/秒 量子化ビット数: 8ビット 記録媒体: 32 × 10^6 バイトの容量を持つUSBメモリ この条件で、最大何分間の音声を保存できるか。\n計算\n1秒あたりのデータ量 11,000 回/秒 × 8 ビット/回 = 88,000 ビット/秒\n1分あたりのデータ量（バイト単位）\n88,000 ビット/秒 × 60 秒/分 = 5,280,000 ビット/分 5,280,000 ビット/分 / 8 ビット/バイト = 660,000 バイト/分 記録可能な時間（分） 32,000,000 バイト / 660,000 バイト/分 ≈ 48.48 分\n答え 最大 48分\nアローダイアグラムにおける総余裕日数（H31春午前問53） # 問題 応用情報技術者試験 平成31年春期 午前問53 より引用\n上図のアローダイアグラムにおいて、総余裕日数は何日か。\n計算 総余裕日数は「その作業の開始をどれだけ遅らせても、プロジェクト全体のスケジュールに影響を与えないか」を示す日数。以下の手順で計算する。\n最遅結合点時刻の計算（終点から始点へ） B・C・G・H のルート（60日） プロジェクトの最短完了日数（クリティカルパス）は 60日。\n最早結合点時刻の計算（始点から終点へ） H・D・B（30日）\n作業Fの総余裕日数の計算 総余裕日数 = 最遅結合点時刻 - 最早結合点時刻 総余裕日数 = 60 - 30 = 30\n答え 30日\n","date":"2025年 9月 1日","externalUrl":null,"permalink":"/scraps/ouyoujouhou-memo/","section":"Scraps","summary":"","title":"勉強メモ-応用情報技術者試験","type":"scraps"},{"content":" 0.はじめに # このチートシートは、NumPyの基本的な使い方から少し応用的な内容までを、解説とコード例付きでまとめたものです。\n1. NumPyとは？ # NumPyは、Pythonで科学技術計算を効率的に行うためのコアライブラリです。特に、多次元配列（ndarray）を高速に扱うための機能が豊富に用意されており、データ分析や機械学習の分野で必須のツールとなっています。\n2. インストールとインポート # インストール # まず、NumPyライブラリをインストールします。ターミナルで以下のコマンドを実行してください。\npip install numpy インポート # Pythonスクリプト内でNumPyを使うには、import文を記述します。慣例として np という別名を付けてインポートするのが一般的です。\nimport numpy as np 3. 配列 (ndarray) の作成 # NumPyの基本は ndarray オブジェクトです。様々な方法で配列を作成できます。\n目的 コード例 解説 リストから作成 np.array([1, 2, 3]) Pythonのリストやタプルを元にNumPy配列を作成します。 連番配列の作成 np.arange(0, 10, 2) range関数のように、指定した範囲とステップで要素を生成します (この例では [0, 2, 4, 6, 8])。 ゼロ行列 np.zeros((2, 3)) すべての要素が 0 の配列を生成します。形状をタプルで指定します (この例では2行3列)。 全要素が1の行列 np.ones((3, 2)) すべての要素が 1 の配列を生成します。 単位行列 np.eye(3) 対角成分が 1 で、それ以外が 0 の正方行列（単位行列）を生成します (この例では3x3)。 コード例:\n# Pythonのリストから2次元配列を作成 arr2d = np.array([[1, 2, 3], [4, 5, 6]]) print(arr2d) #=\u0026gt; [[1 2 3] # [4 5 6]] # 0から9までの整数の配列を作成 range_arr = np.arange(10) print(range_arr) #=\u0026gt; [0 1 2 3 4 5 6 7 8 9] 4. 配列の基本情報 # 配列がどのようなものかを確認するための属性です。\narr = np.array([[1, 2, 3], [4, 5, 6]]) を例とします。\n属性 コード 結果 解説 形状 (Shape) arr.shape (2, 3) 配列の各次元の要素数をタプルで返します (行数, 列数)。 次元数 (Dimensions) arr.ndim 2 配列の次元の数を返します。 要素数 (Size) arr.size 6 配列に含まれる全要素の数を返します。 データ型 (Data Type) arr.dtype int64 配列の要素のデータ型を返します。 5. インデックスとスライシング # 配列から特定の要素や部分を取り出す操作です。\na = np.arange(10) B = np.array([[1,2,3],[4,5,6],[7,8,9]]) を例とします。\n目的 コード例 解説 要素へのアクセス a[3]\nB[1, 2] インデックスを指定して要素を取得します。B[1, 2]は2行目・3列目の要素 6 を返します。 スライシング a[2:5] [start:stop] の形式で、指定した範囲の要素を抽出します (この例ではインデックス2から4まで)。 逆順 a[::-1] 配列の要素を逆順にします。 行・列の抽出 B[0, :]\nB[:, 1] : はその軸のすべての要素を意味します。B[0, :]は1行目全体、B[:, 1]は2列目全体を抽出します。 部分行列の抽出 B[1:, 1:] 2行目以降、かつ2列目以降の要素を抽出します。 6. 配列の操作 # 目的 コード例 解説 形状変更 arr.reshape(3, 2) 要素数を変えずに配列の形状を変更します。 転置 arr.T 行と列を入れ替えた配列を返します。 垂直結合 np.vstack((arr1, arr2)) 2つの配列を垂直（行）方向に結合します。 水平結合 np.hstack((arr1, arr2)) 2つの配列を水平（列）方向に結合します。 垂直分割 np.vsplit(arr, 2) 配列を垂直方向に指定した数に分割します。 水平分割 np.hsplit(arr, 2) 配列を水平方向に指定した数に分割します。 コード例:\ne = np.arange(12) #=\u0026gt; [0, 1, ..., 11] reshaped_e = e.reshape(3, 4) print(reshaped_e) #=\u0026gt; [[ 0 1 2 3] # [ 4 5 6 7] # [ 8 9 10 11]] print(reshaped_e.T) # 転置 #=\u0026gt; [[ 0 4 8] # [ 1 5 9] # [ 2 6 10] # [ 3 7 11]] 7. 配列の演算 # 基本的な演算 # a = np.array([[1, 2], [3, 4]]), b = np.array([[5, 6], [7, 8]]) を例とします。\n目的 演算子 関数 解説 要素ごとの加減乗除 +, -, *, / - 同じ位置にある要素同士で計算が行われます。 行列積 @ np.dot(a, b) 数学的な行列の積を計算します。 スカラー倍 * - a * 3 のように、配列の全要素を定数倍します。 ブロードキャスト # 形状が異なる配列同士の演算でも、NumPyが自動的に形状を拡張して計算する機能です。\narr = np.array([[1, 2, 3], [4, 5, 6]]) scalar = np.array([10, 20, 30]) # arr(2x3)とscalar(1x3)の加算 # scalarがarrの各行に対して加算される result = arr + scalar print(result) #=\u0026gt; [[11 22 33] # [14 25 36]] 8. 数学・統計関数 # 統計関数 # data = np.array([[2, 4, 6], [-1, 5, -3]]) を例とします。\n目的 コード例 解説 最大値 data.max() 全要素の中での最大値を返します。 最小値 data.min() 全要素の中での最小値を返します。 合計 data.sum() 全要素の合計を返します。 平均 data.mean() 全要素の平均値を返します。 分散 data.var() 全要素の分散を返します。 標準偏差 data.std() 全要素の標準偏差を返します。 軸(axis)の指定: axis引数を指定することで、行ごとや列ごとの計算が可能です。\naxis=0: 列方向の計算（各列での集計） axis=1: 行方向の計算（各行での集計） # 列ごとの合計 print(data.sum(axis=0)) #=\u0026gt; [1 9 3] # 行ごとの最小値 print(data.min(axis=1)) #=\u0026gt; [2 -3] ユニバーサル関数 (UFuncs) # 配列の各要素に対して数学的な関数を適用します。\n目的 コード例 平方根 np.sqrt(arr) 指数関数 np.exp(arr) 三角関数 np.sin(arr), np.cos(arr) 線形代数 # np.linalg モジュールには線形代数関連の関数が含まれています。\n目的 コード例 行列式 np.linalg.det(matrix) 逆行列 np.linalg.inv(matrix) 固有値・固有ベクトル np.linalg.eig(matrix) 参考リンク # 【NumPy徹底講座】この動画1本で数値計算に特化したPythonライブラリNumPyの基礎をマスター！ ","date":"2025年 9月 1日","externalUrl":null,"permalink":"/scraps/study-numpy/","section":"Scraps","summary":"","title":"勉強メモ：numpy","type":"scraps"},{"content":" スクラップメモの目的 2025/08/19 質の高い勉強メモを作成するために、いわゆる「メモ術」を学ぼうと思い、この本に出会いました。 各チャプターごとに内容をスクラップメモとして整理しながら学習していきます。 書籍情報 2025/08/19 タイトル：TAKE NOTES!――メモで、あなただけのアウトプットが自然にできるようになる 著者名：ズンク・アーレンス 翻訳：二木 夢子 出版社：日経BP 発売日：2021/10/14 出版社へのリンク はじめに 2025/08/19 『Take Notes!』では、日常的に「質の高いメモ」を蓄積することで、誰もが効率良く、かつ高品質なアウトプットを継続的に生み出せると説かれています。何もないところから考えを生み出すのは容易ではありませんが、日々積み重ねたメモは新たな発想や深い思考の支えとなります。こうした成果を安定して生み出すためには、偶発的な意志力だけに依存せず、システムやルールとしてメモ術を整えることが効果的です。本書は、知的生産を助ける「賢いメモ」を日常的に書き溜めていくことの価値を提案しています。 第1章「メモのとり方」を知れば、大作が自然に書ける 2025/08/20 第1章では「メモの有効性」と「ツェッテルカステン（Zettelkasten）」の考え方が紹介されている。 文章執筆にはいくつかのハードルがある。たとえば、計画通りに筆が進まずモチベーションを失ってしまう、情報収集に力を入れすぎて理想が高くなりすぎる、さらには「自分には能力が足りないのでは」と感じるインポスター症候群に陥る、といった問題である。 こうした課題を乗り越え、質の高いアウトプットにつなげる解決策として提案されているのが「日常的にメモを取る」という習慣である。 その具体的な実践法として、社会学者ニクラス・ルーマンが実践した「ツェッテルカステン」が紹介される。この方法では、小さな単位のメモを作り、それらを相互にリンクさせていく。そのつながりが新たな文脈や洞察を生み、結果として効率的かつ創造的にアイデアを発展させることができる。 第2章 メモをとればとるほど、財産になる 2025/08/23 第2章では、「メモを蓄積して運用する方法」が解説されている。 自分の言葉で書き直しながらメモを作成することで、思考を整理でき、知識やアイデアをより深く理解できるようになる。 ツェッテルカステンにおけるメモの処理フローは次のとおりである。 走り書きメモ：日常で浮かんだアイデアや考えを一時的に記録する。\n文献メモ：読書や記事から得た情報を要約して残す。 これらを基に、自分の言葉で再構成した 「永久保存メモ」 を作成する。\nこれは一つひとつが独立した知識単位となり、今後も再利用できる。 永久保存メモを、既存のメモと関連づける。\n番号やリンクを用いて結びつけ、ネットワークとしての知識体系を育てる。 メモが十分に育った段階で、アウトプット（文章や研究など）につなげていく。 このようにしてメモを日常的に運用していけば、単なる情報の収集にとどまらず、体系的な知識の基盤を築くことができる。 第3章 必要なのはシンプルに「ペン」と「紙」/ 第4章 「メモ」はあなたオリジナルの「思考」を生む魔法のツール 2025/08/23 ツェッテルカステンに必要なのはペンと紙。ツールはシンプルで問題ない。 メモは貯めるだけでは不十分で活用するためのルールやシステムが必要。 第5章 メモをとれば、書くことではなく、思考に集中できる 2025/08/24 アウトプットが重要。アウトプット前提でインプットすることを意識すれば、情報に対する姿勢が変わる 第6章 メモをとるときは、つながりを意識する 2025/08/24 メモは単に貯めただけでは知識として機能しない。全体を振り返って関係性を探り、メモ同士の関連や優先度を整理することで、質の高い洞察へと至る。こうした整理の過程そのものが、理解を促進する重要なステップとなる。 第7章 メモをとれば、オリジナルのテーマと資料が自然に揃う 2025/08/24 メモを書いて、自分のアイデアを貯めていけば、自然と自分の興味を持つテーマが決まる 第8章 メモをがあれば、大作も書ける 2025/08/24 フィードバックや批評はアイデアをレベルアップさせるために必要。 フィードバックなしでは特定の主張に偏る可能性が高くなるため。 第10章 読書メモは、自分の言葉で書こう 2025/08/24 文献や書籍を読んだ内容は「自分の言葉」に言い換えて書き留める。 自分の言葉で言い換えができなければ、理解不足と判断できる。 感想文 2025/08/24 本書のテーマは「ツェッテルカステン」というシステムに基づいてメモを蓄積すれば、質の高いアウトプットが可能になる、というものだ。\n内容を一言でまとめるなら、「メモに関する自己啓発書」である。ツェッテルカステンをはじめ、メモ術に関する知識やエピソードが紹介されており、モチベーションを高めたり、考え方の指針を得るには役立つ。ただし、同じ趣旨の説明が繰り返される印象もあり、体系的にメモ術を学びたい人には少し物足りないかもしれない。\nまた、具体的なハウツーが詳細に整理されているわけではないので、「操作マニュアルとして読む」よりも、「メモの意義や可能性を再確認し、刺激を受けるために読む」ことに向いていると感じた。各章ごとのトピックをつまみ食い感覚で参照する読み方が、最もこの本を活かせるのではないだろうか。 ","date":"2025年 8月 19日","externalUrl":null,"permalink":"/scraps/memo-take-notes/","section":"Scraps","summary":"","title":"読書メモ：TAKE NOTES!","type":"scraps"},{"content":" 1.はじめに # オンラインミーティングにてパソコンの内部音声だけクリアに録音したいときにVoicemeeterでの 録音がおすすめです。 オンラインミーティングを録音する場合は必ず参加メンバーの許可を取ってから録音してください。 Windowsの標準機能だけでは、この「PC内部音声の録音」は少し手間がかかります。しかし、フリーソフト「Voicemeeter」を使えば、PC内部の音声を録音できるようになります。この記事では、Voicemeeterのインストールから設定、そして実際にサウンドレコーダーで録音するまでの手順を、簡潔に解説します。\nVoicemeeterについて公式サイトの説明\nVoicemeeter は、任意のオーディオデバイスやアプリケーションから、またはそれらへのあらゆる音声ソースをミックス・管理するために、仮想入出力（Virtual I/O）として機能する仮想オーディオデバイスを備えたオーディオミキサーアプリケーションです。\n2.ハンズオン # voicemeeterの入手とインストール # VB=AUDIO softwareからvoicemeeterをダウンロード voicemeetersetupをインストール PCを再起動 voicemeeterのセットアップ # 「サウンド」にて出力デバイスを設定 「サウンド」にて入力デバイスを設定 各設定 # Voicemeeter Out B1\t仮想出力 B1（Default VAIO） 一般的な仮想マイク（Google Meet等） Voicemeeter Out B2\t仮想出力 B2（AUX VAIO） Zoomなど別ルート用に使う Voicemeeter Out B3\t仮想出力 B3（VAIO3） さらに追加の音声ルートが欲しい時 Voicemeeter Out A1〜A5\t物理的な出力（スピーカーなど） 録音や再生には使わない voicemeeterを起動 voicemeeterの「Streo Input」にて対象のマイクを設定 voicemeeterの「Streo Input」にて対象のスピーカーを設定 サウンドレコーダーで録音 # ※録音時はVoicemeeterを起動するして、上記の入出力デバイスに設定する必要がある 準備ができたら録音 3.参考リンク # Youtube：【Windows 11】パソコン内音声を録音する手順 VB=AUDIO software ","date":"2025年 8月 10日","externalUrl":null,"permalink":"/posts/how-to-record-pc-internal-audio/","section":"Posts","summary":"","title":"【Windows】Voicemeeterを使ってパソコン内音声を録音する手順","type":"posts"},{"content":"","date":"2025年 8月 7日","externalUrl":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":" git worktree ハンズオン # 1. はじめに # git worktree とは？ # git worktree は、1つのGitリポジトリに対して、複数のワーキングツリー（作業ディレクトリ）を同時に作成し、管理するためのGitコマンドです。\n通常、git checkout を使ってブランチを切り替えると、現在のワーキングツリーの内容が対象ブランチのものに完全に置き換わります。しかし、git worktree を利用すると、異なるブランチをそれぞれ別のディレクトリにチェックアウトした状態に保つことができます。\ngit worktree はどのような時に便利か？ # この機能は、以下のような状況で非常に役立ちます。\n機能開発とバグ修正の並行作業: 大規模な新機能（例: feature-A）の開発中に、本番環境で発生した緊急のバグ（例: hotfix）にすぐ対応する必要がある場合。feature-Aの作業をgit stashなどで退避させることなく、別のディレクトリでhotfixブランチの作業をすぐに始められます。 複数の機能の同時開発: 複数のフィーチャーブランチを並行して開発し、それぞれの動作確認を簡単に行いたい場合。ブランチごとにディレクトリが分かれているため、ビルド成果物などが混ざり合うこともありません。 2. ハンズオン # Step 0: 準備 # まず、ハンズオン用のリポジトリを準備します。\n# 1. 作業用のディレクトリを作成し、移動します mkdir git-worktree-handson-tutorial cd git-worktree-handson-tutorial # 2. Gitリポジトリを初期化します git init # 3. 最初のファイルを作成してコミットします echo \u0026#34;Hello World\u0026#34; \u0026gt; main.txt git add main.txt git commit -m \u0026#34;first commit\u0026#34; Step 1: feature-A のためのワークツリー作成 # mainブランチとは別の場所で、新しい機能 feature-A の開発に着手します。そのために、専用のワークツリーを作成しましょう。\n# \u0026#39;feature-A\u0026#39; という名前の新しいブランチを、\u0026#39;feature-a-worktree\u0026#39; というディレクトリに作成します git worktree add ./feature-a-worktree -b feature-A ./feature-a-worktree: 新しく作成されるディレクトリのパスです。 -b feature-A: 新しく作成するブランチの名前です。このブランチが feature-a-worktree ディレクトリにチェックアウトされます。 git worktree list コマンドで、現在のワークツリーの状態を確認してみましょう。\ngit worktree list 以下のような出力が表示され、2つのワークツリーが存在することがわかります。\n/path/to/git-worktree-handson-tutorial (bare) /path/to/git-worktree-handson-tutorial/feature-a-worktree [feature-A] Step 2: feature-A ワークツリーでの作業 # feature-A の開発作業を進めます。\n# 1. feature-A のワークツリーに移動します cd feature-a-worktree # 2. 現在のブランチを確認します git branch # =\u0026gt; * feature-A # 3. feature-A のための新しいファイルを作成し、コミットします echo \u0026#34;Goodby World\u0026#34; \u0026gt; feature-A.txt git add feature-A.txt git commit -m \u0026#34;feat: Add feature-A file\u0026#34; これで、feature-Aブランチに新しいコミットが追加されました。\nStep 3: feature-A のマージ # feature-Aの開発が完了したと仮定して、mainブランチにマージします。\n# 1. 元のワークツリー（mainブランチ）に移動します cd .. # 2. main ブランチにいることを確認します git branch # =\u0026gt; * main # 3. feature-A ブランチをマージします git merge feature-A git log --graph --oneline --all を実行すると、feature-Aがmainブランチにマージされた歴史を確認できます。\nStep 4: ワークツリーのクリーンアップ # 作業が完了したブランチのワークツリーは不要なので、削除してリポジトリを整理します。\n# ワークツリーの一覧を再度確認 git worktree list # 不要になったワークツリーを削除する # 注意: ワークツリー内に未コミットの変更が残っている場合、削除は失敗します。 # その場合は --force オプションで強制削除できます。 git worktree remove feature-a-worktree # .gitの管理情報から削除されるだけで、ディレクトリ自体は残るため手動で削除します rm -rf feature-a-worktree git worktree prune コマンドは、何らかの理由でディレクトリだけが先に削除されてしまった場合に、関連する管理情報をクリーンアップするのに役立ちます。\n3. まとめ # このハンズオンでは、以下のことを学びました。\ngit worktree add で新しいワークツリーとブランチを作成する方法 複数のワークツリー間を cd で自由に移動し、並行して作業を進める方法 作業が完了したワークツリーを git worktree remove で安全に削除する方法 git worktree を活用することで、ブランチの切り替えに伴う時間のかかるビルドや依存関係の再インストールといった手間を回避し、開発効率を劇的に向上させることができます。ぜひ、日々の開発に取り入れてみてください。\n4. コマンドリファレンス # # 指定したパスに新しいワークツリーを作成 # 同時に新しいブランチを作成してチェックアウトする git worktree add \u0026lt;path\u0026gt; -b \u0026lt;branch-name\u0026gt; # ワークツリーの一覧を表示 git worktree list # 指定したパスのワークツリーを削除 git worktree remove \u0026lt;path\u0026gt; # ワークツリーの管理情報をクリーンアップ git worktree prune 5. 参考リンク # Qiita：徹底解説：git worktree の使い方 git-worktree - Manage multiple working trees ","date":"2025年 8月 7日","externalUrl":null,"permalink":"/posts/git-worktree-hands-on/","section":"Posts","summary":"","title":"git worktree ハンズオン","type":"posts"},{"content":" はじめに # Blowfishではデフォルトで「フグ」のアイコンがfaviconとして設定されています。 デフォルトから自分好みのfaviconへ変更する手順を下記にまとめます。\n設定方法 # faviconの変更は、プロジェクトの static ディレクトリに独自の画像ファイルを配置するだけで完了します。\n. └── static/ ├─ android-chrome-192x192.png ├─ android-chrome-512x512.png ├─ apple-touch-icon.png ├─ favicon-16x16.png ├─ favicon-32x32.png ├─ favicon.ico └─ site.webmanifest これらのファイルと同じ名前で作成したご自身の画像を、プロジェクトのルートにある static フォルダに配置してください。 ファイルを配置した後、Hugoサーバーを再起動（またはビルド）すると、新しいfaviconがサイトに反d映されます。 hugo.tomlなどの設定ファイルでパスを記述する必要はありません。staticディレクトリに置かれたファイルが優先的に読み込まれる仕組みです。\n各ファイルの説明 # staticディレクトリに配置する各ファイルは、様々なデバイスや状況でサイトのアイコンを表示するために利用されます。\nfavicon.ico:\n用途: 最も伝統的なfavicon形式。主にPCブラウザのタブやブックマークで使われます。古いブラウザとの互換性のために重要です。 favicon-16x16.png / favicon-32x32.png:\n用途: 最新のPCブラウザが使用するPNG形式のfavicon。 16x16px: 標準的な解像度のディスプレイのブラウザタブに表示されます。 32x32px: Retinaディスプレイのような高解像度の画面や、タスクバーなどで使用されます。 apple-touch-icon.png:\n用途: iPhoneやiPadなど、Apple製品で「ホーム画面に追加」した際に表示されるアプリアイコンです。180x180pxが推奨サイズです。 android-chrome-192x192.png / android-chrome-512x512.png:\n用途: AndroidデバイスのChromeブラウザで「ホーム画面に追加」した際に使われます。 192x192px: ホーム画面のアイコンとして表示されます。 512x512px: サイト起動時のスプラッシュスクリーンに表示されることがあります。 site.webmanifest:\n用途: ウェブアプリマニフェストと呼ばれる設定ファイルです。サイト名やテーマカラー、そして上記のような各アイコンへのパスを定義し、ブラウザにどのアイコンを使うべきかを伝えます。 これらのファイルを揃えることで、あらゆる環境でサイトのアイコンが意図通りに表示されるようになります。\nfavicon作成に便利なサイト # favicon.io\n1つの画像から、主要なプラットフォーム向けのfavicon一式を生成してくれます。\nICOON MONO\n各種アイコン素材をダウンロードできます。\n参考リンク # Blowfish_favicon\n","date":"2025年 8月 3日","externalUrl":null,"permalink":"/posts/favicon_settings/","section":"Posts","summary":"","title":"BlowfishでFaviconを設定する方法","type":"posts"},{"content":"","date":"2025年 8月 3日","externalUrl":null,"permalink":"/tags/github/","section":"Tags","summary":"","title":"Github","type":"tags"},{"content":" はじめに # 私は普段、Githubのプライベートリポジトリにメモやアイデアを書き溜めています。 リポジトリには、清書したメモなどを保管。Issuesに一時メモや作業メモをまとめています。 （IssuesについてはZennのスクラップと同じような感じで利用しています。） しかし、Issuesの作業メモなどは書き溜めた後、コピー\u0026amp;ペーストするような方法ばかりで、 効率的に活用できていませんでした。\nこの問題を解決するため、Issuesをmarkdownファイルとしてダウンロードして、ローカル環境で管理することを決めました。この記事では、GitHub CLIを使ってGitHubのIssuesをmarkdownファイルとしてダウンロードする方法を紹介します。\n最終的には下記コマンドを実行すればIssuesを取得することが可能です。\n# Issueの取得（jqコマンドで日時フォーマットを日本語表記に変換） gh issue view \u0026lt;ISSUE_NUMBER\u0026gt; --repo \u0026lt;OWNER/REPO\u0026gt; --comments --json comments | jq -r \u0026#39;.comments[] | \u0026#34;## コメント (\u0026#34; + (.createdAt | strptime(\u0026#34;%Y-%m-%dT%H:%M:%SZ\u0026#34;) | strftime(\u0026#34;%Y年%m月%d日 %H時%M分\u0026#34;)) + \u0026#34;)\\n\\n\u0026#34; + .body + \u0026#34;\\n\\n---\\n\u0026#34;\u0026#39; \u0026gt; \u0026lt;FILENAME\u0026gt;.md 対象読者：\nGithub CLIの基本的な使い方を知っている方 ドキュメント作成や記事執筆の素材としてIssuesを活用したい方 Isseusを取得する対象としてはプライベートリポジトリかつ、Githubの無料プランを利用しているユーザーを想定しております。\nパブリックリポジトリまたは有料プランユーザーの場合は、Github Wiki機能など互換性のある機能があるため、そちらを利用するほうが手順も簡単で、効率的にドキュメント運用できると考えられます。 前提条件\nOS: Linux（Ubuntu）環境（WSL2含む） 権限: GitHubにて対象リポジトリへのアクセス権限を保有している サンプル: 当記事ではサンプルリポジトリ（mr110825/gemini-cli-test-repo）を例として説明します 環境セットアップ # GitHub CLIのインストール # # インストール状況の確認 gh --version # GitHub CLIのインストール（必要な場合） sudo apt install gh GitHub CLIへのログイン # # ログイン状況の確認 gh auth status # GitHub CLIへログイン実行 gh auth login GitHub CLIへのログイン手順の詳細については、以下の記事をご参照ください。\n【Git のセットアップ】GitHub CLI を使って GitHub に接続する GitHub CLIのクイックスタート リポジトリのIssues一覧確認 # gh issue list --repo \u0026lt;OWNER/REPO\u0026gt; 実行例 # # サンプルのリポジトリ（mr110825/gemini-cli-test-repo）のIssueを対象とする gh issue list --repo mr110825/gemini-cli-test-repo 出力例 # ID TITLE LABELS UPDATED #1 サンプル用のIssues about 1 hour ago Issueの取得 # gh issue view \u0026lt;ISSUE_NUMBER\u0026gt; --repo \u0026lt;OWNER/REPO\u0026gt; --comments \u0026gt; \u0026lt;FILENAME\u0026gt;.md 実行例 # # サンプルのリポジトリ（mr110825/gemini-cli-test-repo）のIssues#1を「test1.md」として取得する gh issue view 1 --repo mr110825/gemini-cli-test-repo --comments \u0026gt; test1.md 出力例 # author:\tmr110825 association:\towner edited:\ttrue status:\tnone -- 記事を投稿するので構成をまとめる -- author:\tmr110825 association:\towner edited:\ttrue status:\tnone -- 必要な手順 - [x] 文章企画を構成 - [x] サンプルのリポジトリを作成 - [x] 記事作成 - [x] 記事投稿 -- この方法は最もシンプルですが、出力されるファイルには多くのメタデータが含まれており、実際の内容を読みにくく感じました。\n特に、複数のコメントがある場合、どのコメントがどのタイミングで投稿されたのかが分かりにくいという問題があります。 Issueの取得（不要なプロパティを除外してISO形式でコメントのみを取得） # gh issue view \u0026lt;ISSUE_NUMBER\u0026gt; --repo \u0026lt;OWNER/REPO\u0026gt; --comments --json comments --template \u0026#39;{{range .comments}}## コメント ({{.createdAt}}) {{.body}} --- {{end}}\u0026#39; \u0026gt; \u0026lt;FILENAME\u0026gt;.md 実行例 # # サンプルのリポジトリ（mr110825/gemini-cli-test-repo）のIssues#1を「test2.md」として取得する gh issue view 1 --repo mr110825/gemini-cli-test-repo --comments --json comments --template \u0026#39;{{range .comments}}## コメント ({{.createdAt}}) {{.body}} --- {{end}}\u0026#39; \u0026gt; test2.md 出力例 # ## コメント (2025-06-28T12:24:28Z) 記事を投稿するので構成をまとめる --- ## コメント (2025-06-28T12:25:50Z) 必要な手順 - [x] 文章企画を構成 - [x] サンプルのリポジトリを作成 - [x] 記事作成 - [x] 記事投稿 --- この方法では、メタデータが除去され、コメントの内容と投稿日時が明確に表示されるようになりました。\nしかし、ISO形式の日時表記は読みづらいため、さらに改善が必要です。 Issueの取得（jqコマンドで日時フォーマットを日本語表記に変換） # gh issue view \u0026lt;ISSUE_NUMBER\u0026gt; --repo \u0026lt;OWNER/REPO\u0026gt; --comments --json comments | jq -r \u0026#39;.comments[] | \u0026#34;## コメント (\u0026#34; + (.createdAt | strptime(\u0026#34;%Y-%m-%dT%H:%M:%SZ\u0026#34;) | strftime(\u0026#34;%Y年%m月%d日 %H時%M分\u0026#34;)) + \u0026#34;)\\n\\n\u0026#34; + .body + \u0026#34;\\n\\n--- \u0026#34;\u0026#39; \u0026gt; \u0026lt;FILENAME\u0026gt;.md # jqコマンドのインストール（必要な場合） sudo apt install jq 実行例 # # サンプルのリポジトリ（mr110825/gemini-cli-test-repo）のIssues#1を「test3.md」として取得する gh issue view 1 --repo mr110825/gemini-cli-test-repo --comments --json comments | jq -r \u0026#39;.comments[] | \u0026#34;## コメント (\u0026#34; + (.createdAt | strptime(\u0026#34;%Y-%m-%dT%H:%M:%SZ\u0026#34;) | strftime(\u0026#34;%Y年%m月%d日 %H時%M分\u0026#34;)) + \u0026#34;)\\n\\n\u0026#34; + .body + \u0026#34;\\n\\n--- \u0026#34;\u0026#39; \u0026gt; test3.md 出力例 # ## コメント (2025年06月28日 12時24分) 記事を投稿するので構成をまとめる --- ## コメント (2025年06月28日 12時25分) 必要な手順 - [x] 文章企画を構成 - [x] サンプルのリポジトリを作成 - [x] 記事作成 - [x] 記事投稿 --- この方法が最も実用的です。日本語表記により、日時が直感的に理解でき、ドキュメントとして保存した際にも読みやすくなります。ただし、jqコマンドのインストールが必要になるため、環境によっては追加のセットアップが必要になります。 Issueの本文とコメントを取得（jqコマンドで日時フォーマットを日本語表記に変換） # Issueの本文とコメントの両方を取得したい場合は、gh コマンドで取得するJSONフィールドにtitleとbodyを追加し、jqのフィルタを修正します。\n# Issueのタイトル、本文、コメントを取得（jqコマンドで日時フォーマットを日本語表記に変換） gh issue view \u0026lt;ISSUE_NUMBER\u0026gt; --repo \u0026lt;OWNER/REPO\u0026gt; --comments --json title,body,comments | jq -r \u0026#39;\u0026#34;# \u0026#34; + .title + \u0026#34;\\n\\n\u0026#34; + \u0026#34;## Issue本文\\n\\n\u0026#34; + .body + \u0026#34;\\n\\n---\u0026#34;, (.comments[] | \u0026#34;## コメント (\u0026#34; + (.createdAt | strptime(\u0026#34;%Y-%m-%dT%H:%M:%SZ\u0026#34;) | strftime(\u0026#34;%Y年%m月%d日 %H時%M分\u0026#34;)) + \u0026#34;)\\n\\n\u0026#34; + .body + \u0026#34;\\n\\n---\u0026#34;)\u0026#39; \u0026gt; \u0026lt;FILENAME\u0026gt;.md これにより、最初にIssueのタイトルと本文が出力され、その後に整形されたコメントが続くMarkdownファイルが生成されます。\nコマンドリファレンス # # Issues一覧確認 gh issue list --repo \u0026lt;OWNER/REPO\u0026gt; # Issueの取得 gh issue view \u0026lt;ISSUE_NUMBER\u0026gt; --repo \u0026lt;OWNER/REPO\u0026gt; --comments \u0026gt; \u0026lt;FILENAME\u0026gt;.md # Issueの取得（不要なプロパティを除外してISO形式でコメントのみを取得） gh issue view \u0026lt;ISSUE_NUMBER\u0026gt; --repo \u0026lt;OWNER/REPO\u0026gt; --comments --json comments --template \u0026#39;{{range .comments}}## コメント ({{.createdAt}}) {{.body}} --- {{end}}\u0026#39; \u0026gt; \u0026lt;FILENAME\u0026gt;.md # Issueの取得（jqコマンドで日時フォーマットを日本語表記に変換） gh issue view \u0026lt;ISSUE_NUMBER\u0026gt; --repo \u0026lt;OWNER/REPO\u0026gt; --comments --json comments | jq -r \u0026#39;.comments[] | \u0026#34;## コメント (\u0026#34; + (.createdAt | strptime(\u0026#34;%Y-%m-%dT%H:%M:%SZ\u0026#34;) | strftime(\u0026#34;%Y年%m月%d日 %H時%M分\u0026#34;)) + \u0026#34;)\\n\\n\u0026#34; + .body + \u0026#34;\\n\\n--- \u0026#34;\u0026#39; \u0026gt; \u0026lt;FILENAME\u0026gt;.md まとめ # Github CLIを使用してIssuesをMarkdownファイルとしてダウンロードする方法を紹介しました。特に、jqコマンドを使用した日本語表記でのダウンロード方法が、実用的で読みやすい結果を得られると感じています。\nこの方法により、オフライン環境でもIssuesの内容を参照でき、ドキュメント作成や記事執筆の素材としても活用できるようになります。実際に使用してみて、いくつかの改善点も見つかりましたが、基本的なニーズを満たすには十分な方法だと思います。\n","date":"2025年 8月 3日","externalUrl":null,"permalink":"/posts/how_to_download_github_issues/","section":"Posts","summary":"","title":"Github CLIでIssuesをMarkdownファイルとしてダウンロードする方法","type":"posts"}]