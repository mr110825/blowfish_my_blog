
[{"content":"","date":"2025年 9月 4日","externalUrl":null,"permalink":"/scraps/","section":"Scraps","summary":"","title":"Scraps","type":"scraps"},{"content":"","date":"2025年 9月 4日","externalUrl":null,"permalink":"/","section":"技術的デジャブ回避メモ帳","summary":"","title":"技術的デジャブ回避メモ帳","type":"page"},{"content":" pyenvとは？ # pyenvは、Pythonの複数のバージョンを簡単に切り替えて管理するためのツールです。プロジェクトごとに異なるPythonバージョンを利用したい場合などに役立ちます。\nインストール手順 (Ubuntu) # 1. 依存関係のインストール # Pythonのビルドに必要なパッケージをあらかじめインストールします。\nsudo apt update sudo apt install build-essential libffi-dev libssl-dev zlib1g-dev liblzma-dev libbz2-dev libreadline-dev libsqlite3-dev tk-dev git ※参考記事：Ubuntuにpyenvをインストール\n2. pyenvのインストール # GitHubからpyenvのリポジトリをクローンします。\ngit clone https://github.com/pyenv/pyenv.git ~/.pyenv 3. 環境変数の設定（パスを通す） # ~/.bashrc（Zshの場合は ~/.zshrc）に以下の3行を追記します。\necho \u0026#39;export PYENV_ROOT=\u0026#34;$HOME/.pyenv\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#39;command -v pyenv \u0026gt;/dev/null || export PATH=\u0026#34;$PYENV_ROOT/bin:$PATH\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#39;eval \u0026#34;$(pyenv init -)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc 設定を反映させるため、ターミナルを再起動するか、source ~/.bashrc を実行します。\n基本的な使い方 # Pythonのインストール # # インストール可能なバージョンの一覧を表示 pyenv install --list # 指定したバージョンをインストール pyenv install 3.10.4 使用するPythonのバージョンを切り替える # pyenvでは、global と local の2つの方法でバージョンを指定できます。\nglobal: システム全体でデフォルトとして使用するバージョンを設定します。 local: 現在のディレクトリ（プロジェクト）でのみ有効なバージョンを設定します。 # インストール済みのバージョン一覧を確認 pyenv versions # 全体で使うバージョンを設定 pyenv global 3.10.4 # 現在のディレクトリで使うバージョンを設定（.python-versionファイルが作成される） pyenv local 3.9.13 Pythonのアンインストール # pyenv uninstall 3.10.4 pyenvのアップデート # 方法1: pyenv-updateプラグインを使う # pyenv-updateというプラグインを導入すると、pyenv updateコマンドで簡単に更新できます。\n# 1. プラグインをインストール（初回のみ） git clone https://github.com/pyenv/pyenv-update.git $(pyenv root)/plugins/pyenv-update # 2. pyenvをアップデート pyenv update 方法2: gitで直接アップデートする # pyenv本体はgitリポジトリなので、git pullで直接更新することも可能です。\ncd $(pyenv root) git pull インストール時のトラブルシューティング # pyenv install 時にエラーが出た場合の対処法です。多くは依存パッケージ不足が原因です。\nconfigure: error: no acceptable C compiler found in $PATH # Cコンパイラが見つからないエラーです。build-essentialをインストールします。\nsudo apt install build-essential zipimport.ZipImportError: can't decompress data; zlib not available # zlibライブラリがないエラーです。zlib1g-devをインストールします。\nsudo apt install zlib1g-dev ","date":"2025年 9月 4日","externalUrl":null,"permalink":"/scraps/study-pyenv/","section":"Scraps","summary":"","title":"勉強メモ：pyenv","type":"scraps"},{"content":" はじめに # python用の勉強メモをスクラップとしてまとめます。\nPythonとは # Pythonは1991年に開発された、シンプルで読みやすい文法が特徴のプログラミング言語です。\nインデント（字下げ）でコードのブロックを表現することが大きな特徴です。 文法が比較的シンプルなため、プログラミング初心者でも学習しやすい言語と言われています。 近年では、AI開発や機械学習、データ分析などの分野で特に広く活用されています。 Pythonのインストール方法（Linux/Debian系） # Linux（DebianやUbuntuなど）環境でPython3をインストールする手順です。\nsudo apt update sudo apt install -y python3 コマンドの解説\nsudo apt update: インストール可能なパッケージのリストを最新の状態に更新します。 sudo apt install -y python3: Python3をインストールします。 -yオプションは、インストール中の確認メッセージに対して自動的に「Yes」と回答するためのものです。 インストール後の確認 # インストールが正常に完了したかを確認するには、ターミナルで以下のコマンドを実行します。\npython3 --version 次のように、インストールされたPythonのバージョンが表示されれば成功です。\nPython 3.x.x ※ x.xの部分には、インストールされたバージョン番号が表示されます。\nPythonの対話モード # Pythonのプログラムを実行するには、主に2つの方法があります。\n対話モード: ターミナルで直接コードを一行ずつ入力して実行する方法。 スクリプト実行: .pyファイルにコードを記述し、そのファイルを一括で実行する方法。 対話モードは、ターミナルでpython3コマンドを実行すると開始できます。コードを試したり、簡単な計算をしたりするのに便利です。\n$ python3 Python 3.x.x (default, ... Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;Hello, Python!\u0026#34;) Hello, Python! \u0026gt;\u0026gt;\u0026gt; 対話モードを終了するには、exit()と入力するか、Ctrl + Dを押します。\nNumpy # NumpyではPythonで科学技術計算を効率的に行うためのコアライブラリ\nスクラップメモ Numpy解説付きチートシート\npyenv # pyenvとは、Pythonのバージョン管理を簡単にするツール\nスクラップメモ 勉強メモ：pyenv\n","date":"2025年 9月 3日","externalUrl":null,"permalink":"/scraps/styudy-python/","section":"Scraps","summary":"","title":"勉強メモ：Python","type":"scraps"},{"content":"","date":"2025年 9月 1日","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025年 9月 1日","externalUrl":null,"permalink":"/tags/%E5%8B%89%E5%BC%B7%E3%83%A1%E3%83%A2/","section":"Tags","summary":"","title":"勉強メモ","type":"tags"},{"content":" スクラップメモの目的 # 応用情報技術者試験勉強中の知らないキーワードや概念をメモにして整理 参考資料 # 令和07年【春期】【⁠秋期】応用情報技術者 合格教本 応用情報技術者過去問道場 ユーザービリティ評価手法 # アンケート # 質問票を配布してユーザーから回答を集める手法。\n思考発話法 # 被験者に操作をしながら考えていることを声に出してもらい、思考プロセスを分析する手法。\n回顧法 # 操作後に操作内容やその時の判断、感想などを思い出してもらい、ヒアリングする手法。\nログデータ分析法 # ユーザーの操作ログを収集・解析し、利用状況や問題点を定量的に評価する手法。\n認知的ウォークスルー法 # 専門家がユーザーの視点に立ってタスクを実行し、ユーザーが目標を達成できるか、操作で迷わないかなどを評価する手法。\nヒューリスティック評価 # 専門家が経験則（ヒューリスティックス）に基づいて、UIなどがガイドラインに沿っているかを評価する手法。\n二モニックコード # 商品の略称や記号など、記憶しやすいように意味を持たせたコード。 例：「B5」→ B5用紙 別名：表意コード\nパンくずリスト # Webサイト内でユーザーが現在閲覧しているページの位置を、トップページからの階層構造で示したもの。 名前の由来は童話「ヘンゼルとグレーテル」で、主人公が森で迷わないようにパンくずを落として道しるべにした逸話から。\nコンピュータグラフィックスの基本技術 # レンダリング # 3D空間の物体のデータ（形状、質感、光源など）を基に、2次元の画像を生成する処理。\nレイトレーシング法 # 光源から出た光が物体に反射し、視点に届くまでの経路を逆に追跡することで、リアルな画像を生成するレンダリング手法。光の反射や屈折を精密に計算できる。\nZバッファ法 # 視点からの奥行き情報（Z値）をピクセルごとに保持し、不要な部分（隠れた部分）を描画しないことで、効率的に隠面消去を行うレンダリング手法。\nラジオシティ法 # 物体表面での光の相互反射（間接光）を計算することで、柔らかな陰影や、部屋の壁が照らし合う様子などをリアルに表現するレンダリング手法。\nアンチエイリアシング # 斜線や曲線の境界に生じる階段状のギザギザ（ジャギー）を、中間色を補うことで滑らかに見せる手法。\nディザリング # 色数が限られた環境で、異なる色のピクセルを隣接して配置することで、擬似的に中間色や多くの色を表現する手法。\nメタボール # 複数の球体を定義し、それらが融合し合うような滑らかで有機的な曲面を生成するモデリング手法。液体や粘体などの表現に用いられる。\nパルス符号変調（PCM）の符号化手順 # 標本化（サンプリング） アナログ信号を一定の時間間隔で区切り、その瞬間の値を取り出す。1秒間にサンプリングする回数をサンプリング周波数（Hz）と呼ぶ。\n量子化 標本化で得られたアナログ値を、最も近い離散的な値（整数値）に近似する。このとき、1つの値を表現するために使うビット数を量子化ビット数と呼ぶ。\n符号化 量子化で得られた整数値を、0と1の2進符号に変換する。\n全般統制と業務処理統制の違い # 全般統制：組織や集団全体を対象 業務処理統制：個々の業務が対象 システム監査基準 # 監査人が従うべき行動規範\n計算問題 # 帯域幅（R6秋午前問26） # 問題\n解像度: 800 × 600 ピクセル 色深度: 24ビットフルカラー フレームレート: 30フレーム/秒 上記の動画像の配信に最低限必要な帯域幅はいくつか。\n計算\n1フレームあたりのデータ量 800 × 600 ピクセル × 24 ビット/ピクセル = 11,520,000 ビット = 11.52 Mビット\n1秒あたりのデータ量（帯域幅） 11.52 Mビット/フレーム × 30 フレーム/秒 = 345.6 Mビット/秒 (Mbps)\n答え 345.6 Mbps\n色数（H17春午前問22） # 問題 あるディスプレイのビデオメモリは、解像度「800 × 600画素」で最大「2^16色」の表示が可能である。このビデオメモリを流用して解像度を「1600 × 1200画素」に変更した場合、表示できる最大の色数はいくつか。\n計算\n必要なビデオメモリ容量の計算\n1画素あたりのデータ量: 2^16色を表現するには16ビット（= 2バイト）必要。 ビデオメモリ容量: 800 × 600 画素 × 2 バイト/画素 = 960,000 バイト 変更後の解像度で1画素あたりに割り当てられるデータ量の計算\n変更後の総画素数: 1600 × 1200 画素 = 1,920,000 画素 1画素あたりのデータ量: 960,000 バイト / 1,920,000 画素 = 0.5 バイト = 4 ビット 最大色数の計算 4ビットで表現できる色数は 2^4 色。\n答え 2^4色\n音声サンプリング（H18春午前問55） # 問題\nサンプリング周波数: 11,000回/秒 量子化ビット数: 8ビット 記録媒体: 32 × 10^6 バイトの容量を持つUSBメモリ この条件で、最大何分間の音声を保存できるか。\n計算\n1秒あたりのデータ量 11,000 回/秒 × 8 ビット/回 = 88,000 ビット/秒\n1分あたりのデータ量（バイト単位）\n88,000 ビット/秒 × 60 秒/分 = 5,280,000 ビット/分 5,280,000 ビット/分 / 8 ビット/バイト = 660,000 バイト/分 記録可能な時間（分） 32,000,000 バイト / 660,000 バイト/分 ≈ 48.48 分\n答え 最大 48分\nアローダイアグラムにおける総余裕日数（H31春午前問53） # 問題 応用情報技術者試験 平成31年春期 午前問53 より引用\n上図のアローダイアグラムにおいて、総余裕日数は何日か。\n計算 総余裕日数は「その作業の開始をどれだけ遅らせても、プロジェクト全体のスケジュールに影響を与えないか」を示す日数。以下の手順で計算する。\n最遅結合点時刻の計算（終点から始点へ） B・C・G・H のルート（60日） プロジェクトの最短完了日数（クリティカルパス）は 60日。\n最早結合点時刻の計算（始点から終点へ） H・D・B（30日）\n作業Fの総余裕日数の計算 総余裕日数 = 最遅結合点時刻 - 最早結合点時刻 総余裕日数 = 60 - 30 = 30\n答え 30日\n","date":"2025年 9月 1日","externalUrl":null,"permalink":"/scraps/ouyoujouhou-memo/","section":"Scraps","summary":"","title":"勉強メモ-応用情報技術者試験","type":"scraps"},{"content":" 0.はじめに # このチートシートは、NumPyの基本的な使い方から少し応用的な内容までを、解説とコード例付きでまとめたものです。\n1. NumPyとは？ # NumPyは、Pythonで科学技術計算を効率的に行うためのコアライブラリです。特に、多次元配列（ndarray）を高速に扱うための機能が豊富に用意されており、データ分析や機械学習の分野で必須のツールとなっています。\n2. インストールとインポート # インストール # まず、NumPyライブラリをインストールします。ターミナルで以下のコマンドを実行してください。\npip install numpy インポート # Pythonスクリプト内でNumPyを使うには、import文を記述します。慣例として np という別名を付けてインポートするのが一般的です。\nimport numpy as np 3. 配列 (ndarray) の作成 # NumPyの基本は ndarray オブジェクトです。様々な方法で配列を作成できます。\n目的 コード例 解説 リストから作成 np.array([1, 2, 3]) Pythonのリストやタプルを元にNumPy配列を作成します。 連番配列の作成 np.arange(0, 10, 2) range関数のように、指定した範囲とステップで要素を生成します (この例では [0, 2, 4, 6, 8])。 ゼロ行列 np.zeros((2, 3)) すべての要素が 0 の配列を生成します。形状をタプルで指定します (この例では2行3列)。 全要素が1の行列 np.ones((3, 2)) すべての要素が 1 の配列を生成します。 単位行列 np.eye(3) 対角成分が 1 で、それ以外が 0 の正方行列（単位行列）を生成します (この例では3x3)。 コード例:\n# Pythonのリストから2次元配列を作成 arr2d = np.array([[1, 2, 3], [4, 5, 6]]) print(arr2d) #=\u0026gt; [[1 2 3] # [4 5 6]] # 0から9までの整数の配列を作成 range_arr = np.arange(10) print(range_arr) #=\u0026gt; [0 1 2 3 4 5 6 7 8 9] 4. 配列の基本情報 # 配列がどのようなものかを確認するための属性です。\narr = np.array([[1, 2, 3], [4, 5, 6]]) を例とします。\n属性 コード 結果 解説 形状 (Shape) arr.shape (2, 3) 配列の各次元の要素数をタプルで返します (行数, 列数)。 次元数 (Dimensions) arr.ndim 2 配列の次元の数を返します。 要素数 (Size) arr.size 6 配列に含まれる全要素の数を返します。 データ型 (Data Type) arr.dtype int64 配列の要素のデータ型を返します。 5. インデックスとスライシング # 配列から特定の要素や部分を取り出す操作です。\na = np.arange(10) B = np.array([[1,2,3],[4,5,6],[7,8,9]]) を例とします。\n目的 コード例 解説 要素へのアクセス a[3]\nB[1, 2] インデックスを指定して要素を取得します。B[1, 2]は2行目・3列目の要素 6 を返します。 スライシング a[2:5] [start:stop] の形式で、指定した範囲の要素を抽出します (この例ではインデックス2から4まで)。 逆順 a[::-1] 配列の要素を逆順にします。 行・列の抽出 B[0, :]\nB[:, 1] : はその軸のすべての要素を意味します。B[0, :]は1行目全体、B[:, 1]は2列目全体を抽出します。 部分行列の抽出 B[1:, 1:] 2行目以降、かつ2列目以降の要素を抽出します。 6. 配列の操作 # 目的 コード例 解説 形状変更 arr.reshape(3, 2) 要素数を変えずに配列の形状を変更します。 転置 arr.T 行と列を入れ替えた配列を返します。 垂直結合 np.vstack((arr1, arr2)) 2つの配列を垂直（行）方向に結合します。 水平結合 np.hstack((arr1, arr2)) 2つの配列を水平（列）方向に結合します。 垂直分割 np.vsplit(arr, 2) 配列を垂直方向に指定した数に分割します。 水平分割 np.hsplit(arr, 2) 配列を水平方向に指定した数に分割します。 コード例:\ne = np.arange(12) #=\u0026gt; [0, 1, ..., 11] reshaped_e = e.reshape(3, 4) print(reshaped_e) #=\u0026gt; [[ 0 1 2 3] # [ 4 5 6 7] # [ 8 9 10 11]] print(reshaped_e.T) # 転置 #=\u0026gt; [[ 0 4 8] # [ 1 5 9] # [ 2 6 10] # [ 3 7 11]] 7. 配列の演算 # 基本的な演算 # a = np.array([[1, 2], [3, 4]]), b = np.array([[5, 6], [7, 8]]) を例とします。\n目的 演算子 関数 解説 要素ごとの加減乗除 +, -, *, / - 同じ位置にある要素同士で計算が行われます。 行列積 @ np.dot(a, b) 数学的な行列の積を計算します。 スカラー倍 * - a * 3 のように、配列の全要素を定数倍します。 ブロードキャスト # 形状が異なる配列同士の演算でも、NumPyが自動的に形状を拡張して計算する機能です。\narr = np.array([[1, 2, 3], [4, 5, 6]]) scalar = np.array([10, 20, 30]) # arr(2x3)とscalar(1x3)の加算 # scalarがarrの各行に対して加算される result = arr + scalar print(result) #=\u0026gt; [[11 22 33] # [14 25 36]] 8. 数学・統計関数 # 統計関数 # data = np.array([[2, 4, 6], [-1, 5, -3]]) を例とします。\n目的 コード例 解説 最大値 data.max() 全要素の中での最大値を返します。 最小値 data.min() 全要素の中での最小値を返します。 合計 data.sum() 全要素の合計を返します。 平均 data.mean() 全要素の平均値を返します。 分散 data.var() 全要素の分散を返します。 標準偏差 data.std() 全要素の標準偏差を返します。 軸(axis)の指定: axis引数を指定することで、行ごとや列ごとの計算が可能です。\naxis=0: 列方向の計算（各列での集計） axis=1: 行方向の計算（各行での集計） # 列ごとの合計 print(data.sum(axis=0)) #=\u0026gt; [1 9 3] # 行ごとの最小値 print(data.min(axis=1)) #=\u0026gt; [2 -3] ユニバーサル関数 (UFuncs) # 配列の各要素に対して数学的な関数を適用します。\n目的 コード例 平方根 np.sqrt(arr) 指数関数 np.exp(arr) 三角関数 np.sin(arr), np.cos(arr) 線形代数 # np.linalg モジュールには線形代数関連の関数が含まれています。\n目的 コード例 行列式 np.linalg.det(matrix) 逆行列 np.linalg.inv(matrix) 固有値・固有ベクトル np.linalg.eig(matrix) 参考リンク # 【NumPy徹底講座】この動画1本で数値計算に特化したPythonライブラリNumPyの基礎をマスター！ ","date":"2025年 9月 1日","externalUrl":null,"permalink":"/scraps/study-numpy/","section":"Scraps","summary":"","title":"NumPy 解説付きチートシート","type":"scraps"},{"content":"","date":"2025年 9月 1日","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"","date":"2025年 8月 19日","externalUrl":null,"permalink":"/tags/%E8%AA%AD%E6%9B%B8%E3%83%A1%E3%83%A2/","section":"Tags","summary":"","title":"読書メモ","type":"tags"},{"content":" スクラップメモの目的 2025/08/19 質の高い勉強メモを作成するために、いわゆる「メモ術」を学ぼうと思い、この本に出会いました。 各チャプターごとに内容をスクラップメモとして整理しながら学習していきます。 書籍情報 2025/08/19 タイトル：TAKE NOTES!――メモで、あなただけのアウトプットが自然にできるようになる 著者名：ズンク・アーレンス 翻訳：二木 夢子 出版社：日経BP 発売日：2021/10/14 出版社へのリンク はじめに 2025/08/19 『Take Notes!』では、日常的に「質の高いメモ」を蓄積することで、誰もが効率良く、かつ高品質なアウトプットを継続的に生み出せると説かれています。何もないところから考えを生み出すのは容易ではありませんが、日々積み重ねたメモは新たな発想や深い思考の支えとなります。こうした成果を安定して生み出すためには、偶発的な意志力だけに依存せず、システムやルールとしてメモ術を整えることが効果的です。本書は、知的生産を助ける「賢いメモ」を日常的に書き溜めていくことの価値を提案しています。 第1章「メモのとり方」を知れば、大作が自然に書ける 2025/08/20 第1章では「メモの有効性」と「ツェッテルカステン（Zettelkasten）」の考え方が紹介されている。 文章執筆にはいくつかのハードルがある。たとえば、計画通りに筆が進まずモチベーションを失ってしまう、情報収集に力を入れすぎて理想が高くなりすぎる、さらには「自分には能力が足りないのでは」と感じるインポスター症候群に陥る、といった問題である。 こうした課題を乗り越え、質の高いアウトプットにつなげる解決策として提案されているのが「日常的にメモを取る」という習慣である。 その具体的な実践法として、社会学者ニクラス・ルーマンが実践した「ツェッテルカステン」が紹介される。この方法では、小さな単位のメモを作り、それらを相互にリンクさせていく。そのつながりが新たな文脈や洞察を生み、結果として効率的かつ創造的にアイデアを発展させることができる。 第2章 メモをとればとるほど、財産になる 2025/08/23 第2章では、「メモを蓄積して運用する方法」が解説されている。 自分の言葉で書き直しながらメモを作成することで、思考を整理でき、知識やアイデアをより深く理解できるようになる。 ツェッテルカステンにおけるメモの処理フローは次のとおりである。 走り書きメモ：日常で浮かんだアイデアや考えを一時的に記録する。\n文献メモ：読書や記事から得た情報を要約して残す。 これらを基に、自分の言葉で再構成した 「永久保存メモ」 を作成する。\nこれは一つひとつが独立した知識単位となり、今後も再利用できる。 永久保存メモを、既存のメモと関連づける。\n番号やリンクを用いて結びつけ、ネットワークとしての知識体系を育てる。 メモが十分に育った段階で、アウトプット（文章や研究など）につなげていく。 このようにしてメモを日常的に運用していけば、単なる情報の収集にとどまらず、体系的な知識の基盤を築くことができる。 第3章 必要なのはシンプルに「ペン」と「紙」/ 第4章 「メモ」はあなたオリジナルの「思考」を生む魔法のツール 2025/08/23 ツェッテルカステンに必要なのはペンと紙。ツールはシンプルで問題ない。 メモは貯めるだけでは不十分で活用するためのルールやシステムが必要。 第5章 メモをとれば、書くことではなく、思考に集中できる 2025/08/24 アウトプットが重要。アウトプット前提でインプットすることを意識すれば、情報に対する姿勢が変わる 第6章 メモをとるときは、つながりを意識する 2025/08/24 メモは単に貯めただけでは知識として機能しない。全体を振り返って関係性を探り、メモ同士の関連や優先度を整理することで、質の高い洞察へと至る。こうした整理の過程そのものが、理解を促進する重要なステップとなる。 第7章 メモをとれば、オリジナルのテーマと資料が自然に揃う 2025/08/24 メモを書いて、自分のアイデアを貯めていけば、自然と自分の興味を持つテーマが決まる 第8章 メモをがあれば、大作も書ける 2025/08/24 フィードバックや批評はアイデアをレベルアップさせるために必要。 フィードバックなしでは特定の主張に偏る可能性が高くなるため。 第10章 読書メモは、自分の言葉で書こう 2025/08/24 文献や書籍を読んだ内容は「自分の言葉」に言い換えて書き留める。 自分の言葉で言い換えができなければ、理解不足と判断できる。 感想文 2025/08/24 本書のテーマは「ツェッテルカステン」というシステムに基づいてメモを蓄積すれば、質の高いアウトプットが可能になる、というものだ。\n内容を一言でまとめるなら、「メモに関する自己啓発書」である。ツェッテルカステンをはじめ、メモ術に関する知識やエピソードが紹介されており、モチベーションを高めたり、考え方の指針を得るには役立つ。ただし、同じ趣旨の説明が繰り返される印象もあり、体系的にメモ術を学びたい人には少し物足りないかもしれない。\nまた、具体的なハウツーが詳細に整理されているわけではないので、「操作マニュアルとして読む」よりも、「メモの意義や可能性を再確認し、刺激を受けるために読む」ことに向いていると感じた。各章ごとのトピックをつまみ食い感覚で参照する読み方が、最もこの本を活かせるのではないだろうか。 ","date":"2025年 8月 19日","externalUrl":null,"permalink":"/scraps/memo-take-notes/","section":"Scraps","summary":"","title":"読書メモ：TAKE NOTES!","type":"scraps"},{"content":" 1.はじめに # オンラインミーティングにてパソコンの内部音声だけクリアに録音したいときにVoicemeeterでの 録音がおすすめです。 オンラインミーティングを録音する場合は必ず参加メンバーの許可を取ってから録音してください。 Windowsの標準機能だけでは、この「PC内部音声の録音」は少し手間がかかります。しかし、フリーソフト「Voicemeeter」を使えば、PC内部の音声を録音できるようになります。この記事では、Voicemeeterのインストールから設定、そして実際にサウンドレコーダーで録音するまでの手順を、簡潔に解説します。\nVoicemeeterについて公式サイトの説明\nVoicemeeter は、任意のオーディオデバイスやアプリケーションから、またはそれらへのあらゆる音声ソースをミックス・管理するために、仮想入出力（Virtual I/O）として機能する仮想オーディオデバイスを備えたオーディオミキサーアプリケーションです。\n2.ハンズオン # voicemeeterの入手とインストール # VB=AUDIO softwareからvoicemeeterをダウンロード voicemeetersetupをインストール PCを再起動 voicemeeterのセットアップ # 「サウンド」にて出力デバイスを設定 「サウンド」にて入力デバイスを設定 各設定 # Voicemeeter Out B1\t仮想出力 B1（Default VAIO） 一般的な仮想マイク（Google Meet等） Voicemeeter Out B2\t仮想出力 B2（AUX VAIO） Zoomなど別ルート用に使う Voicemeeter Out B3\t仮想出力 B3（VAIO3） さらに追加の音声ルートが欲しい時 Voicemeeter Out A1〜A5\t物理的な出力（スピーカーなど） 録音や再生には使わない voicemeeterを起動 voicemeeterの「Streo Input」にて対象のマイクを設定 voicemeeterの「Streo Input」にて対象のスピーカーを設定 サウンドレコーダーで録音 # ※録音時はVoicemeeterを起動するして、上記の入出力デバイスに設定する必要がある 準備ができたら録音 3.参考リンク # Youtube：【Windows 11】パソコン内音声を録音する手順 VB=AUDIO software ","date":"2025年 8月 10日","externalUrl":null,"permalink":"/posts/how-to-record-pc-internal-audio/","section":"Posts","summary":"","title":"【Windows】Voicemeeterを使ってパソコン内音声を録音する手順","type":"posts"},{"content":"","date":"2025年 8月 10日","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2025年 8月 7日","externalUrl":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":" git worktree ハンズオン # 1. はじめに # git worktree とは？ # git worktree は、1つのGitリポジトリに対して、複数のワーキングツリー（作業ディレクトリ）を同時に作成し、管理するためのGitコマンドです。\n通常、git checkout を使ってブランチを切り替えると、現在のワーキングツリーの内容が対象ブランチのものに完全に置き換わります。しかし、git worktree を利用すると、異なるブランチをそれぞれ別のディレクトリにチェックアウトした状態に保つことができます。\ngit worktree はどのような時に便利か？ # この機能は、以下のような状況で非常に役立ちます。\n機能開発とバグ修正の並行作業: 大規模な新機能（例: feature-A）の開発中に、本番環境で発生した緊急のバグ（例: hotfix）にすぐ対応する必要がある場合。feature-Aの作業をgit stashなどで退避させることなく、別のディレクトリでhotfixブランチの作業をすぐに始められます。 複数の機能の同時開発: 複数のフィーチャーブランチを並行して開発し、それぞれの動作確認を簡単に行いたい場合。ブランチごとにディレクトリが分かれているため、ビルド成果物などが混ざり合うこともありません。 2. ハンズオン # Step 0: 準備 # まず、ハンズオン用のリポジトリを準備します。\n# 1. 作業用のディレクトリを作成し、移動します mkdir git-worktree-handson-tutorial cd git-worktree-handson-tutorial # 2. Gitリポジトリを初期化します git init # 3. 最初のファイルを作成してコミットします echo \u0026#34;Hello World\u0026#34; \u0026gt; main.txt git add main.txt git commit -m \u0026#34;first commit\u0026#34; Step 1: feature-A のためのワークツリー作成 # mainブランチとは別の場所で、新しい機能 feature-A の開発に着手します。そのために、専用のワークツリーを作成しましょう。\n# \u0026#39;feature-A\u0026#39; という名前の新しいブランチを、\u0026#39;feature-a-worktree\u0026#39; というディレクトリに作成します git worktree add ./feature-a-worktree -b feature-A ./feature-a-worktree: 新しく作成されるディレクトリのパスです。 -b feature-A: 新しく作成するブランチの名前です。このブランチが feature-a-worktree ディレクトリにチェックアウトされます。 git worktree list コマンドで、現在のワークツリーの状態を確認してみましょう。\ngit worktree list 以下のような出力が表示され、2つのワークツリーが存在することがわかります。\n/path/to/git-worktree-handson-tutorial (bare) /path/to/git-worktree-handson-tutorial/feature-a-worktree [feature-A] Step 2: feature-A ワークツリーでの作業 # feature-A の開発作業を進めます。\n# 1. feature-A のワークツリーに移動します cd feature-a-worktree # 2. 現在のブランチを確認します git branch # =\u0026gt; * feature-A # 3. feature-A のための新しいファイルを作成し、コミットします echo \u0026#34;Goodby World\u0026#34; \u0026gt; feature-A.txt git add feature-A.txt git commit -m \u0026#34;feat: Add feature-A file\u0026#34; これで、feature-Aブランチに新しいコミットが追加されました。\nStep 3: feature-A のマージ # feature-Aの開発が完了したと仮定して、mainブランチにマージします。\n# 1. 元のワークツリー（mainブランチ）に移動します cd .. # 2. main ブランチにいることを確認します git branch # =\u0026gt; * main # 3. feature-A ブランチをマージします git merge feature-A git log --graph --oneline --all を実行すると、feature-Aがmainブランチにマージされた歴史を確認できます。\nStep 4: ワークツリーのクリーンアップ # 作業が完了したブランチのワークツリーは不要なので、削除してリポジトリを整理します。\n# ワークツリーの一覧を再度確認 git worktree list # 不要になったワークツリーを削除する # 注意: ワークツリー内に未コミットの変更が残っている場合、削除は失敗します。 # その場合は --force オプションで強制削除できます。 git worktree remove feature-a-worktree # .gitの管理情報から削除されるだけで、ディレクトリ自体は残るため手動で削除します rm -rf feature-a-worktree git worktree prune コマンドは、何らかの理由でディレクトリだけが先に削除されてしまった場合に、関連する管理情報をクリーンアップするのに役立ちます。\n3. まとめ # このハンズオンでは、以下のことを学びました。\ngit worktree add で新しいワークツリーとブランチを作成する方法 複数のワークツリー間を cd で自由に移動し、並行して作業を進める方法 作業が完了したワークツリーを git worktree remove で安全に削除する方法 git worktree を活用することで、ブランチの切り替えに伴う時間のかかるビルドや依存関係の再インストールといった手間を回避し、開発効率を劇的に向上させることができます。ぜひ、日々の開発に取り入れてみてください。\n4. コマンドリファレンス # # 指定したパスに新しいワークツリーを作成 # 同時に新しいブランチを作成してチェックアウトする git worktree add \u0026lt;path\u0026gt; -b \u0026lt;branch-name\u0026gt; # ワークツリーの一覧を表示 git worktree list # 指定したパスのワークツリーを削除 git worktree remove \u0026lt;path\u0026gt; # ワークツリーの管理情報をクリーンアップ git worktree prune 5. 参考リンク # Qiita：徹底解説：git worktree の使い方 git-worktree - Manage multiple working trees ","date":"2025年 8月 7日","externalUrl":null,"permalink":"/posts/git-worktree-hands-on/","section":"Posts","summary":"","title":"git worktree ハンズオン","type":"posts"},{"content":"","date":"2025年 8月 3日","externalUrl":null,"permalink":"/tags/blowfish/","section":"Tags","summary":"","title":"Blowfish","type":"tags"},{"content":" はじめに # Blowfishではデフォルトで「フグ」のアイコンがfaviconとして設定されています。 デフォルトから自分好みのfaviconへ変更する手順を下記にまとめます。\n設定方法 # faviconの変更は、プロジェクトの static ディレクトリに独自の画像ファイルを配置するだけで完了します。\n. └── static/ ├─ android-chrome-192x192.png ├─ android-chrome-512x512.png ├─ apple-touch-icon.png ├─ favicon-16x16.png ├─ favicon-32x32.png ├─ favicon.ico └─ site.webmanifest これらのファイルと同じ名前で作成したご自身の画像を、プロジェクトのルートにある static フォルダに配置してください。 ファイルを配置した後、Hugoサーバーを再起動（またはビルド）すると、新しいfaviconがサイトに反d映されます。 hugo.tomlなどの設定ファイルでパスを記述する必要はありません。staticディレクトリに置かれたファイルが優先的に読み込まれる仕組みです。\n各ファイルの説明 # staticディレクトリに配置する各ファイルは、様々なデバイスや状況でサイトのアイコンを表示するために利用されます。\nfavicon.ico:\n用途: 最も伝統的なfavicon形式。主にPCブラウザのタブやブックマークで使われます。古いブラウザとの互換性のために重要です。 favicon-16x16.png / favicon-32x32.png:\n用途: 最新のPCブラウザが使用するPNG形式のfavicon。 16x16px: 標準的な解像度のディスプレイのブラウザタブに表示されます。 32x32px: Retinaディスプレイのような高解像度の画面や、タスクバーなどで使用されます。 apple-touch-icon.png:\n用途: iPhoneやiPadなど、Apple製品で「ホーム画面に追加」した際に表示されるアプリアイコンです。180x180pxが推奨サイズです。 android-chrome-192x192.png / android-chrome-512x512.png:\n用途: AndroidデバイスのChromeブラウザで「ホーム画面に追加」した際に使われます。 192x192px: ホーム画面のアイコンとして表示されます。 512x512px: サイト起動時のスプラッシュスクリーンに表示されることがあります。 site.webmanifest:\n用途: ウェブアプリマニフェストと呼ばれる設定ファイルです。サイト名やテーマカラー、そして上記のような各アイコンへのパスを定義し、ブラウザにどのアイコンを使うべきかを伝えます。 これらのファイルを揃えることで、あらゆる環境でサイトのアイコンが意図通りに表示されるようになります。\nfavicon作成に便利なサイト # favicon.io\n1つの画像から、主要なプラットフォーム向けのfavicon一式を生成してくれます。\nICOON MONO\n各種アイコン素材をダウンロードできます。\n参考リンク # Blowfish_favicon\n","date":"2025年 8月 3日","externalUrl":null,"permalink":"/posts/favicon_settings/","section":"Posts","summary":"","title":"BlowfishでFaviconを設定する方法","type":"posts"},{"content":"","date":"2025年 8月 3日","externalUrl":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo","type":"tags"},{"content":"","date":"2025年 8月 3日","externalUrl":null,"permalink":"/tags/github/","section":"Tags","summary":"","title":"Github","type":"tags"},{"content":" はじめに # 私は普段、Githubのプライベートリポジトリにメモやアイデアを書き溜めています。 リポジトリには、清書したメモなどを保管。Issuesに一時メモや作業メモをまとめています。 （IssuesについてはZennのスクラップと同じような感じで利用しています。） しかし、Issuesの作業メモなどは書き溜めた後、コピー\u0026amp;ペーストするような方法ばかりで、 効率的に活用できていませんでした。\nこの問題を解決するため、Issuesをmarkdownファイルとしてダウンロードして、ローカル環境で管理することを決めました。この記事では、GitHub CLIを使ってGitHubのIssuesをmarkdownファイルとしてダウンロードする方法を紹介します。\n最終的には下記コマンドを実行すればIssuesを取得することが可能です。\n# Issueの取得（jqコマンドで日時フォーマットを日本語表記に変換） gh issue view \u0026lt;ISSUE_NUMBER\u0026gt; --repo \u0026lt;OWNER/REPO\u0026gt; --comments --json comments | jq -r \u0026#39;.comments[] | \u0026#34;## コメント (\u0026#34; + (.createdAt | strptime(\u0026#34;%Y-%m-%dT%H:%M:%SZ\u0026#34;) | strftime(\u0026#34;%Y年%m月%d日 %H時%M分\u0026#34;)) + \u0026#34;)\\n\\n\u0026#34; + .body + \u0026#34;\\n\\n---\\n\u0026#34;\u0026#39; \u0026gt; \u0026lt;FILENAME\u0026gt;.md 対象読者：\nGithub CLIの基本的な使い方を知っている方 ドキュメント作成や記事執筆の素材としてIssuesを活用したい方 Isseusを取得する対象としてはプライベートリポジトリかつ、Githubの無料プランを利用しているユーザーを想定しております。\nパブリックリポジトリまたは有料プランユーザーの場合は、Github Wiki機能など互換性のある機能があるため、そちらを利用するほうが手順も簡単で、効率的にドキュメント運用できると考えられます。 前提条件\nOS: Linux（Ubuntu）環境（WSL2含む） 権限: GitHubにて対象リポジトリへのアクセス権限を保有している サンプル: 当記事ではサンプルリポジトリ（mr110825/gemini-cli-test-repo）を例として説明します 環境セットアップ # GitHub CLIのインストール # # インストール状況の確認 gh --version # GitHub CLIのインストール（必要な場合） sudo apt install gh GitHub CLIへのログイン # # ログイン状況の確認 gh auth status # GitHub CLIへログイン実行 gh auth login GitHub CLIへのログイン手順の詳細については、以下の記事をご参照ください。\n【Git のセットアップ】GitHub CLI を使って GitHub に接続する GitHub CLIのクイックスタート リポジトリのIssues一覧確認 # gh issue list --repo \u0026lt;OWNER/REPO\u0026gt; 実行例 # # サンプルのリポジトリ（mr110825/gemini-cli-test-repo）のIssueを対象とする gh issue list --repo mr110825/gemini-cli-test-repo 出力例 # ID TITLE LABELS UPDATED #1 サンプル用のIssues about 1 hour ago Issueの取得 # gh issue view \u0026lt;ISSUE_NUMBER\u0026gt; --repo \u0026lt;OWNER/REPO\u0026gt; --comments \u0026gt; \u0026lt;FILENAME\u0026gt;.md 実行例 # # サンプルのリポジトリ（mr110825/gemini-cli-test-repo）のIssues#1を「test1.md」として取得する gh issue view 1 --repo mr110825/gemini-cli-test-repo --comments \u0026gt; test1.md 出力例 # author:\tmr110825 association:\towner edited:\ttrue status:\tnone -- 記事を投稿するので構成をまとめる -- author:\tmr110825 association:\towner edited:\ttrue status:\tnone -- 必要な手順 - [x] 文章企画を構成 - [x] サンプルのリポジトリを作成 - [x] 記事作成 - [x] 記事投稿 -- この方法は最もシンプルですが、出力されるファイルには多くのメタデータが含まれており、実際の内容を読みにくく感じました。\n特に、複数のコメントがある場合、どのコメントがどのタイミングで投稿されたのかが分かりにくいという問題があります。 Issueの取得（不要なプロパティを除外してISO形式でコメントのみを取得） # gh issue view \u0026lt;ISSUE_NUMBER\u0026gt; --repo \u0026lt;OWNER/REPO\u0026gt; --comments --json comments --template \u0026#39;{{range .comments}}## コメント ({{.createdAt}}) {{.body}} --- {{end}}\u0026#39; \u0026gt; \u0026lt;FILENAME\u0026gt;.md 実行例 # # サンプルのリポジトリ（mr110825/gemini-cli-test-repo）のIssues#1を「test2.md」として取得する gh issue view 1 --repo mr110825/gemini-cli-test-repo --comments --json comments --template \u0026#39;{{range .comments}}## コメント ({{.createdAt}}) {{.body}} --- {{end}}\u0026#39; \u0026gt; test2.md 出力例 # ## コメント (2025-06-28T12:24:28Z) 記事を投稿するので構成をまとめる --- ## コメント (2025-06-28T12:25:50Z) 必要な手順 - [x] 文章企画を構成 - [x] サンプルのリポジトリを作成 - [x] 記事作成 - [x] 記事投稿 --- この方法では、メタデータが除去され、コメントの内容と投稿日時が明確に表示されるようになりました。\nしかし、ISO形式の日時表記は読みづらいため、さらに改善が必要です。 Issueの取得（jqコマンドで日時フォーマットを日本語表記に変換） # gh issue view \u0026lt;ISSUE_NUMBER\u0026gt; --repo \u0026lt;OWNER/REPO\u0026gt; --comments --json comments | jq -r \u0026#39;.comments[] | \u0026#34;## コメント (\u0026#34; + (.createdAt | strptime(\u0026#34;%Y-%m-%dT%H:%M:%SZ\u0026#34;) | strftime(\u0026#34;%Y年%m月%d日 %H時%M分\u0026#34;)) + \u0026#34;)\\n\\n\u0026#34; + .body + \u0026#34;\\n\\n---\\n\u0026#34;\u0026#39; \u0026gt; \u0026lt;FILENAME\u0026gt;.md # jqコマンドのインストール（必要な場合） sudo apt install jq 実行例 # # サンプルのリポジトリ（mr110825/gemini-cli-test-repo）のIssues#1を「test3.md」として取得する gh issue view 1 --repo mr110825/gemini-cli-test-repo --comments --json comments | jq -r \u0026#39;.comments[] | \u0026#34;## コメント (\u0026#34; + (.createdAt | strptime(\u0026#34;%Y-%m-%dT%H:%M:%SZ\u0026#34;) | strftime(\u0026#34;%Y年%m月%d日 %H時%M分\u0026#34;)) + \u0026#34;)\\n\\n\u0026#34; + .body + \u0026#34;\\n\\n---\\n\u0026#34;\u0026#39; \u0026gt; test3.md 出力例 # ## コメント (2025年06月28日 12時24分) 記事を投稿するので構成をまとめる --- ## コメント (2025年06月28日 12時25分) 必要な手順 - [x] 文章企画を構成 - [x] サンプルのリポジトリを作成 - [x] 記事作成 - [x] 記事投稿 --- この方法が最も実用的です。日本語表記により、日時が直感的に理解でき、ドキュメントとして保存した際にも読みやすくなります。ただし、jqコマンドのインストールが必要になるため、環境によっては追加のセットアップが必要になります。 コマンドリファレンス # # Issues一覧確認 gh issue list --repo \u0026lt;OWNER/REPO\u0026gt; # Issueの取得 gh issue view \u0026lt;ISSUE_NUMBER\u0026gt; --repo \u0026lt;OWNER/REPO\u0026gt; --comments \u0026gt; \u0026lt;FILENAME\u0026gt;.md # Issueの取得（不要なプロパティを除外してISO形式でコメントのみを取得） gh issue view \u0026lt;ISSUE_NUMBER\u0026gt; --repo \u0026lt;OWNER/REPO\u0026gt; --comments --json comments --template \u0026#39;{{range .comments}}## コメント ({{.createdAt}}) {{.body}} --- {{end}}\u0026#39; \u0026gt; \u0026lt;FILENAME\u0026gt;.md # Issueの取得（jqコマンドで日時フォーマットを日本語表記に変換） gh issue view \u0026lt;ISSUE_NUMBER\u0026gt; --repo \u0026lt;OWNER/REPO\u0026gt; --comments --json comments | jq -r \u0026#39;.comments[] | \u0026#34;## コメント (\u0026#34; + (.createdAt | strptime(\u0026#34;%Y-%m-%dT%H:%M:%SZ\u0026#34;) | strftime(\u0026#34;%Y年%m月%d日 %H時%M分\u0026#34;)) + \u0026#34;)\\n\\n\u0026#34; + .body + \u0026#34;\\n\\n---\\n\u0026#34;\u0026#39; \u0026gt; \u0026lt;FILENAME\u0026gt;.md まとめ # Github CLIを使用してIssuesをMarkdownファイルとしてダウンロードする方法を紹介しました。特に、jqコマンドを使用した日本語表記でのダウンロード方法が、実用的で読みやすい結果を得られると感じています。\nこの方法により、オフライン環境でもIssuesの内容を参照でき、ドキュメント作成や記事執筆の素材としても活用できるようになります。実際に使用してみて、いくつかの改善点も見つかりましたが、基本的なニーズを満たすには十分な方法だと思います。\n","date":"2025年 8月 3日","externalUrl":null,"permalink":"/posts/how_to_download_github_issues/","section":"Posts","summary":"","title":"Github CLIでIssuesをMarkdownファイルとしてダウンロードする方法","type":"posts"}]